<!DOCTYPE html>
<html lang="hi">
<head>
    

    <meta charset="utf-8">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <title>GPS Map Camera - Ultra Pro Max (Official Final Build)</title>
    <meta name="description" content="GPS Map Camera app to capture photos with real-time GPS location, address, latitude longitude and map watermark. Camera with location stamp for survey and inspection.">
    <meta name="keywords" content="gps map camera, camera with gps location, gps photo camera, location camera app, geo tag camera, camera with location stamp, gps coordinates camera, map camera gps">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#000000">

    <style>
        /* CSS ROOT VARIABLES */
        :root {
            --primary-color: #00e676;
            --secondary-color: #1e88e5;
            --danger-color: #ff5252;
            --dark-bg: #000000;
            --overlay-bg: rgba(0, 0, 0, 0.82);
            --text-color: #ffffff;
            --glass-border: rgba(255, 255, 255, 0.18);
            --font-main: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            --shadow-heavy: 0 15px 55px rgba(0, 0, 0, 0.85);
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            outline: none;
            margin: 0;
            padding: 0;
        }

        body {
            background: var(--dark-bg);
            color: var(--text-color);
            font-family: var(--font-main);
            overflow: hidden;
            user-select: none;
            height: 100vh;
            width: 100vw;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        #video-preview, #capture-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: black;
            z-index: 1;
        }

        .camera-switching {
            opacity: 0;
            transform: scale(0.95);
            filter: blur(15px);
            transition: all 0.4s ease-in-out;
        }

        #video-preview {
            transition: transform 0.5s ease, opacity 0.4s ease;
        }

        #capture-canvas {
            display: none;
        }

        .mirrored {
            transform: scaleX(-1);
        }

        #data-overlay {
            position: absolute;
            bottom: 195px;
            left: 15px;
            width: 370px;
            max-height: 120px;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            padding: 10px;
            color: #fff;
            font-size: 10.5px;
            overflow: hidden;
            z-index: 15;
            pointer-events: none;
        }

        #data-overlay .address-line {
            white-space: normal;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .data-row {
            font-size: 11px;
            display: flex;
            align-items: flex-start;
            gap: 8px;
        }

        .data-label {
            font-weight: bold;
            width: 20px;
            text-align: center;
            font-size: 12px;
            opacity: 0.9;
        }

        .data-value {
            color: #f2f2f2;
            flex: 1;
            line-height: 1.6;
            letter-spacing: 0.3px;
        }

        .status-good {
            color: var(--primary-color);
            font-weight: 900;
            text-shadow: 0 0 10px rgba(0, 230, 118, 0.3);
        }

        .status-bad {
            color: var(--danger-color);
            font-weight: 900;
            text-shadow: 0 0 10px rgba(255, 82, 82, 0.3);
        }

        .btn-circle {
            position: fixed;
            width: 68px;
            height: 68px;
            border-radius: 50%;
            border: none;
            background: var(--secondary-color);
            color: white;
            font-size: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.65);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .btn-circle:active {
            transform: scale(0.82);
            filter: brightness(1.2);
        }

        #capture-btn {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 80px;
            border-radius: 50%;
            z-index: 25;
            background: linear-gradient(145deg, #ffffff, #b0bec5);
            border: 5px solid rgba(255, 255, 255, 0.3);
            box-shadow:
                0 10px 25px rgba(0,0,0,0.5),
                inset 0 2px 4px rgba(255,255,255,0.9),
                inset 0 -3px 6px rgba(0,0,0,0.2);
            cursor: pointer;
        }

        #capture-btn:active {
            transform: translateX(-50%) scale(0.95);
            background: linear-gradient(145deg, #b0bec5, #ffffff);
        }

        #switch-camera {
            position: fixed;
            right: 255px;
            bottom: 35px;
            width: 52px;
            height: 52px;
            border-radius: 50%;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
            border: 1.5px solid rgba(255,255,255,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }

        #toggle-flash {
            position: fixed;
            right: 85px;
            bottom: 35px;
            width: 52px;
            height: 52px;
            border-radius: 50%;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
            border: 1.5px solid rgba(255,255,255,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }

        .flash-active {
            background: rgba(255, 215, 0, 0.3) !important;
            border: 2px solid #FFD700 !important;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.8), inset 0 0 10px #FFD700 !important;
            transform: scale(1.1) !important;
            color: #FFD700 !important;
        }

        #open-settings {
            position: fixed;
            right: 18px;
            bottom: 35px;
            width: 52px;
            height: 52px;
            border-radius: 50%;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
            border: 1.5px solid rgba(255,255,255,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }

        .hero-btn {
            padding: 22px 80px;
            border-radius: 50px;
            border: none;
            background: var(--primary-color);
            font-weight: 900;
            font-size: 22px;
            color: #000;
            box-shadow: 0 15px 45px rgba(0, 230, 118, 0.45);
            cursor: pointer;
            transition: transform 0.3s;
        }
        .hero-btn:active { transform: scale(0.92); }

        .policy-box {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--glass-border);
            border-radius: 15px;
            padding: 15px;
            margin: 20px 0;
            max-height: 180px;
            overflow-y: auto;
            text-align: left;
            font-size: 12px;
            line-height: 1.5;
            color: #ccc;
        }
        .policy-check {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            margin-bottom: 25px;
            color: #fff;
            font-size: 14px;
        }
        .policy-check input {
            width: 20px;
            height: 20px;
            accent-color: var(--primary-color);
        }

        #settings-panel {
            position: fixed;
            bottom: -100%;
            left: 0;
            width: 100%;
            background: #161616;
            border-radius: 38px 38px 0 0;
            padding: 40px 30px 80px 30px;
            z-index: 10000 !important;
            transition: bottom 0.5s cubic-bezier(0.2, 1, 0.3, 1);
            border-top: 5px solid var(--primary-color);
        }

        #settings-panel.active {
            bottom: 0;
        }

        .setting-header {
            margin-top: 0;
            color: var(--primary-color);
            font-size: 24px;
            margin-bottom: 30px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 28px;
        }

        .toggle-label { font-size: 16px; font-weight: 500; }

        input[type=range] {
            width: 140px;
            accent-color: var(--primary-color);
        }

        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px);
            z-index: 3000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s ease-out;
        }

        .modal-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .modal-box {
            background: #1c1c1c;
            border: 1px solid var(--glass-border);
            padding: 45px 35px;
            border-radius: 45px;
            text-align: center;
            width: 92%;
            max-width: 400px;
            box-shadow: 0 45px 90px rgba(0,0,0,0.95);
            transform: scale(0.65) translateY(70px);
            opacity: 0;
            transition: all 0.55s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .modal-overlay.active .modal-box {
            transform: scale(1) translateY(0);
            opacity: 1;
        }

        .modal-title {
            color: var(--primary-color);
            font-size: 26px;
            margin: 15px 0 10px 0;
        }

        .modal-body {
            color: #b0b0b0;
            line-height: 1.6;
            margin-bottom: 35px;
            font-size: 16px;
        }

        .modal-footer {
            display: flex;
            gap: 20px;
        }

        .modal-btn {
            flex: 1;
            padding: 20px;
            border: none;
            border-radius: 22px;
            font-weight: 900;
            font-size: 17px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .modal-btn:active { transform: scale(0.94); }

        .btn-save { background: var(--primary-color); color: #000; box-shadow: 0 8px 25px rgba(0, 230, 118, 0.25); }
        .btn-discard { background: #333; color: #fff; }

        #action-bar {
            position: fixed;
            bottom: -150px;
            left: 20px;
            right: 20px;
            background: #141414;
            border-radius: 30px;
            padding: 20px;
            z-index: 4000;
            display: flex;
            gap: 18px;
            transition: bottom 0.75s cubic-bezier(0.18, 0.89, 0.32, 1.28);
            border: 1.5px solid var(--primary-color);
            box-shadow: 0 25px 60px rgba(0, 230, 118, 0.35);
        }

        #action-bar.show {
            bottom: 35px;
        }

        .action-btn {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            padding: 18px;
            border: none;
            border-radius: 22px;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
        }

        .btn-open { background: #2a2a2a; color: white; }
        .btn-whatsapp { background: #25D366; color: white; }

        #perm-screen {
            position: fixed;
            inset: 0;
            background: #000;
            z-index: 5000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 45px;
        }

        .hero-title {
            color: var(--primary-color);
            font-size: 40px;
            margin: 0 0 20px 0;
            text-shadow: 0 0 20px rgba(0, 230, 118, 0.4);
        }

        .hero-desc {
            color: #777;
            font-size: 18px;
            margin-bottom: 50px;
            max-width: 300px;
            line-height: 1.6;
        }

        #intro-splash {
            position: fixed; inset: 0;
            background: #000;
            z-index: 99999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            font-family: 'Segoe UI', monospace;
            overflow: hidden;
        }

        .grid-bg {
            position: absolute; width: 200%; height: 200%;
            background-image:
                linear-gradient(rgba(0, 255, 136, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 136, 0.05) 1px, transparent 1px);
            background-size: 50px 50px;
            transform: perspective(500px) rotateX(60deg) translateY(-100px) translateZ(-200px);
            animation: grid-move 10s linear infinite;
            opacity: 0.6;
        }
        @keyframes grid-move { 0% {transform: perspective(500px) rotateX(60deg) translateY(0);} 100% {transform: perspective(500px) rotateX(60deg) translateY(50px);} }

        .hud-container {
            position: relative; width: 140px; height: 140px;
            display: flex; align-items: center; justify-content: center;
            margin-bottom: 30px;
        }
        .app-icon { font-size: 50px; z-index: 10; animation: icon-pulse 2s infinite; }

        .hud-ring {
            position: absolute; border-radius: 50%;
            border: 1px solid rgba(0, 230, 118, 0.3);
            box-shadow: 0 0 10px rgba(0, 230, 118, 0.1);
        }
        .outer { width: 100%; height: 100%; border-top-color: #00e676; border-bottom-color: #00e676; animation: spin-cw 4s linear infinite; }
        .middle { width: 75%; height: 75%; border-left-color: #00e676; border-right-color: #00e676; animation: spin-ccw 3s linear infinite; }
        .inner { width: 50%; height: 50%; border: 2px dashed rgba(0, 230, 118, 0.6); animation: spin-cw 5s linear infinite; }
        .hud-scan-line {
            position: absolute; width: 100%; height: 2px; background: #00e676;
            box-shadow: 0 0 10px #00e676;
            animation: radar-scan 2s linear infinite;
            opacity: 0.7;
        }

        @keyframes spin-cw { 100% { transform: rotate(360deg); } }
        @keyframes spin-ccw { 100% { transform: rotate(-360deg); } }
        @keyframes radar-scan { 0% {top:0%; opacity:0;} 50% {opacity:1;} 100% {top:100%; opacity:0;} }

        .splash-title {
            color: #fff; font-size: 28px; font-weight: 800; letter-spacing: 2px;
            margin-bottom: 30px; z-index: 2;
            text-shadow: 0 0 20px rgba(0, 230, 118, 0.4);
        }
        .pro-badge {
            background: #00e676; color: #000; padding: 2px 6px; border-radius: 4px;
            font-size: 14px; vertical-align: middle;
        }

        .system-check-list {
            width: 280px; margin-bottom: 30px; z-index: 2;
        }
        .check-item {
            display: flex; align-items: center; gap: 15px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            color: #888; font-size: 13px;
            transition: all 0.3s;
        }
        .check-item.active { color: #fff; text-shadow: 0 0 5px #00e676; }
        .status-icon { width: 15px; text-align: center; }

        .progress-container {
            width: 240px; display: flex; align-items: center; gap: 10px; z-index: 2;
        }
        .progress-bar {
            flex: 1; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; position: relative;
            overflow: hidden;
        }
        .progress-bar::after {
            content: ''; position: absolute; left: 0; top: 0; height: 100%; width: 0%;
            background: #00e676;
            animation: progress-fill 3.2s cubic-bezier(0.22, 1, 0.36, 1) forwards;
            box-shadow: 0 0 10px #00e676;
        }
        #progress-percent { color: #00e676; font-size: 12px; font-weight: bold; width: 35px; }

        .loading-status {
            margin-top: 15px; font-size: 10px; color: #555; letter-spacing: 3px; z-index: 2;
        }

        @keyframes progress-fill { 0%{width:0%} 100%{width:100%} }
#gallery-grid::-webkit-scrollbar { width: 4px; }
#gallery-grid::-webkit-scrollbar-thumb { background: var(--primary-color); border-radius: 2px; }

.gallery-item {
    position: relative;
    aspect-ratio: 1;
    background: #000;
    border-radius: 8px;
    overflow: hidden;
    border: 1px solid #333;
    cursor: pointer;
}
.gallery-item img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    transition: transform 0.3s;
}
.gallery-item:active img { transform: scale(0.95); opacity: 0.8; }
#viewer-modal {
    background-color: #000000 !important;
}

    </style>
</head>

<body>
<div id="intro-splash">
    <div class="grid-bg"></div>

    <div class="hud-container">
        <div class="hud-ring outer"></div>
        <div class="hud-ring middle"></div>
        <div class="hud-ring inner"></div>
        <div class="hud-scan-line"></div>
        <div class="app-icon material-icons">gps_fixed</div>
    </div>

    <h1 class="splash-title">GPS CAMERA <span class="pro-badge">PRO</span></h1>

    <div class="system-check-list">
        <div class="check-item" id="item-gps">
            <span class="status-icon material-icons">check_circle</span>
            <span class="status-text">Calibrating GPS Sensors...</span>
        </div>
        <div class="check-item" id="item-map">
            <span class="status-icon material-icons">check_circle</span>
            <span class="status-text">Loading Map Overlay...</span>
        </div>
        <div class="check-item" id="item-cam">
            <span class="status-icon material-icons">check_circle</span>
            <span class="status-text">Initializing 4K Lens...</span>
        </div>
        <div class="check-item" id="item-secure">
            <span class="status-icon material-icons">check_circle</span>
            <span class="status-text">Verifying Secure Storage...</span>
        </div>
    </div>

    <div class="progress-container">
        <div class="progress-bar"></div>
        <span id="progress-percent">0%</span>
    </div>

    <p class="loading-status">SYSTEM BOOT SEQUENCE INITIATED</p>
</div>

<video id="video-preview" autoplay playsinline></video>
<canvas id="capture-canvas" style="display:none"></canvas>

<div id="data-overlay">
    <div class="data-row">
        <span class="data-label material-icons">location_on</span>
        <span id="txt-status" class="data-value">Initializing Sensors...</span>
    </div>

    <div class="data-row">
        <span class="data-label material-icons">public</span>
        <span id="txt-coords" class="data-value">0.000000, 0.000000</span>
    </div>

    <div class="data-row">
        <span class="data-label material-icons">home</span>
        <span id="txt-address" class="data-value">Searching Location...</span>
    </div>

    <div class="data-row">
        <span class="data-label material-icons">explore</span>
        <span id="txt-sensors" class="data-value">0¬∞ | 0 km/h | 0.0m</span>
    </div>

    <div class="data-row">
        <span class="data-label material-icons">straighten</span>
        <span id="txt-accuracy" class="data-value status-bad">Accuracy Calibration...</span>
    </div>

    <div class="data-row">
        <span class="data-label material-icons">schedule</span>
        <span id="txt-time" class="data-value">--/--/----, --:-- am/pm</span>
    </div>
</div>

<button id="switch-camera" class="btn-circle material-icons" title="Switch Lens">cameraswitch</button>
<button id="toggle-flash" class="btn-circle material-icons" title="Toggle Light">flash_on</button>
<button id="open-settings" class="btn-circle material-icons" title="Settings">settings</button>
<button id="open-gallery" class="btn-circle material-icons" style="right: 320px; bottom: 35px; width: 52px; height: 52px; background: rgba(0,0,0,0.5); backdrop-filter: blur(10px); border: 1.5px solid rgba(255,255,255,0.2);" title="Gallery">collections</button>
<button id="capture-btn" title="Capture Geotagged Image"></button>

<div id="action-bar">
    <button id="btn-share-whatsapp" class="action-btn btn-whatsapp material-icons">share</button>
    <button id="btn-close-bar" class="material-icons">close</button>
</div>

<div id="save-modal-overlay" class="modal-overlay">
    <div class="modal-box">
        <img id="photo-preview"
             style="width: 100%; max-height: 320px; object-fit: contain; background: #000; border-radius: 20px; margin-bottom: 22px; display: none;" />
        <h2 class="modal-title" style="letter-spacing: 0.5px;">Field Report Generated</h2>
        <p class="modal-body" style="font-size: 15px; color: #ccc;">
            Geotagged documentation captured successfully. <br>
            Verify location data and confirm to save.
        </p>
        <div class="modal-footer">
            <button id="btn-discard" class="modal-btn btn-discard">Discard</button>
            <button id="btn-save" class="modal-btn btn-save">Confirm & Save</button>
        </div>
    </div>
</div>

<div id="success-modal" class="modal-overlay" style="z-index: 20002;">
    <div class="modal-box" style="background: #1c1c1c; border: 1px solid var(--primary-color); text-align: center; max-width: 300px;">
        <div style="margin-bottom: 15px;">
            <span class="material-icons" style="font-size: 55px; color: var(--primary-color); text-shadow: 0 0 15px rgba(0,230,118,0.4);">check_circle</span>
        </div>

        <h2 style="color: #fff; font-size: 20px; margin-bottom: 8px;">Saved Successfully</h2>
        <p style="color: #aaa; font-size: 13px; margin-bottom: 25px;">
            Photo Gallery ‡§Æ‡•á‡§Ç save ‡§π‡•ã ‡§ó‡§à ‡§π‡•à‡•§
        </p>

        <div class="modal-footer" style="flex-direction: column; gap: 10px;">
            <button id="share-success-btn" class="modal-btn" style="background: #25D366; color: white; display: flex; align-items: center; justify-content: center; gap: 8px; width: 100%;">Share</button>
            <button id="close-success-btn" class="modal-btn" style="background: #333; color: #fff; width: 100%;">Close / ‡§¨‡§Ç‡§¶ ‡§ï‡§∞‡•á‡§Ç</button>
        </div>
    </div>
</div>

<div id="settings-panel">
    <h2 class="setting-header">Pro Configurations</h2>
    <div class="setting-item">
        <span class="toggle-label">Accuracy Limit: <b id="lbl-acc-limit">50m</b></span>
        <input id="rng-accuracy" type="range" min="10" max="250" step="5" value="50">
    </div>
    <div class="setting-item">
        <span class="toggle-label">Distance Throttle: <b id="lbl-dist-limit">30m</b></span>
        <input id="rng-distance" type="range" min="10" max="150" step="10" value="30">
    </div>
    <div class="setting-item">
        <span class="toggle-label">Enable Watermark Stamp</span>
        <input id="chk-stamp" type="checkbox" style="width:25px; height:25px;" checked>
    </div>
    <div class="setting-item">
        <span class="toggle-label">High-Res Mode (1080p)</span>
        <input id="chk-hd" type="checkbox" style="width:25px; height:25px;" checked>
    </div>

    <button id="close-settings" style="width:100%; padding:18px; background:#333; color:white; border:none; border-radius:20px; font-weight:bold; margin-top:20px; cursor:pointer;">Theek Hai</button>
</div>

<div id="perm-screen">
    <h1 class="hero-title">GPS Map Camera</h1>
    <p class="hero-desc" id="perm-status">Professional Field Survey Tool</p>

    <div id="perm-content">
        <div class="policy-box">
            <b style="color:var(--primary-color);">Permissions Required:</b><br><br>
            1. <b>Camera:</b> Documentation capture ‡§ï‡•á ‡§≤‡§ø‡§è.<br>
            2. <b>GPS:</b> Real-time location stamping ‡§ï‡•á ‡§≤‡§ø‡§è.<br>
            3. <b>Storage:</b> Photos ‡§ï‡•ã gallery ‡§Æ‡•á‡§Ç save ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è.
        </div>
        <button class="hero-btn" id="btn-start">Accept & Initialize</button>
    </div>

    <div id="denied-content" style="display:none;">
        <p style="color:var(--danger-color); margin-bottom:20px;">Permissions Denied! <br> App ‡§¨‡§ø‡§®‡§æ sensors ‡§ï‡•á ‡§∏‡§π‡•Ä ‡§∏‡•á ‡§ï‡§æ‡§Æ ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞‡•á‡§ó‡•Ä.</p>
        <button class="hero-btn" id="btn-retry-permissions" style="background:var(--danger-color);">Try Again / Grant Access</button>
    </div>
</div>
<div id="gallery-modal" class="modal-overlay">
    <div class="modal-box" style="width: 95%; height: 85%; max-width: 600px; display: flex; flex-direction: column; padding: 20px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h2 class="modal-title" style="margin: 0; font-size: 22px;">Captured Photos</h2>
            <button id="close-gallery" class="material-icons" style="background: none; border: none; color: #fff; font-size: 28px;">close</button>
        </div>
        <div id="gallery-grid" style="flex: 1; overflow-y: auto; display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; align-content: start;"></div>
        <div id="gallery-empty" style="display: none; color: #777; margin-top: 50px;">No photos yet</div>
    </div>
</div>

<div id="viewer-modal" class="modal-overlay" style="z-index: 3500; background: #000000;">
    <img id="viewer-img" style="max-width: 100%; max-height: 80vh; border-radius: 5px; box-shadow: 0 0 20px rgba(0,0,0,0.8);">
    <div style="position: absolute; bottom: 30px; display: flex; gap: 20px;">
        <button id="btn-share-photo" class="hero-btn" style="padding: 15px 30px; font-size: 16px; background: #25D366; color: white;">Share</button>
        <button id="btn-close-viewer" class="hero-btn" style="padding: 15px 30px; font-size: 16px; background: #333; color: white;">Close</button>
        <button id="btn-delete-photo" class="hero-btn" style="padding: 15px 25px; font-size: 16px; background: #ff5252; color: white;">Delete</button>
    </div>
</div>

<script>
    'use strict';

    /* =================================================================
       GLOBAL VARIABLES & CONFIGURATION
       ================================================================= */

    function el(id) { return document.getElementById(id); }

    let isSystemInitialized = false;
    let LAST_SAVED_PHOTO_URI = "";

    // Centralized hardware state
    let stream = null;
    let track = null;
    let facing = "environment";
    let watchId = null;

    let isInterstitialReady = false;
    let isBannerLoaded = false;

    let lastLat = 0;
    let lastLon = 0;
    let lastApiTime = 0;

    let lat = 0;
    let lon = 0;
    let alt = "0m";
    let speed = "0 km/h";
    let accuracy = 999;
    let lastAccuracy = 999;
    let heading = "0¬∞";
    let address = "Searching Location...";

    const video = el("video-preview");
    const canvas = el("capture-canvas");
    const ctx = canvas ? canvas.getContext("2d") : null;
    const actionBar = el("action-bar");
    const saveModal = el("save-modal-overlay");
    const accSlider = el("rng-accuracy");
    const accLabel = el("lbl-acc-limit");
    const distSlider = el("rng-distance");
    const distLabel = el("lbl-dist-limit");

    const shutterAudio = new Audio("data:audio/wav;base64,UklGRiIAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA=");

    const appConfig = {
        applicationId: "com.ravi.gpscamera",
        get playStoreUrl() { return `https://play.google.com/store/apps/details?id=${this.applicationId}`; }
    };

    function safeText(str) {
        if (!str && str !== "") return "";
        try {
            str = String(str).normalize('NFC');
            return str.replace(/\p{C}/gu, '').trim();
        } catch (e) {
            return String(str).replace(/[^\x20-\x7E\u00A0-\uFFFF]/g, '');
        }
    }

    function closeSuccessModal() {
        const modal = el("success-modal");
        if (modal) {
            modal.classList.remove("active");
        }
    }

    async function shareOnWhatsApp() {
        if (!LAST_SAVED_PHOTO_URI) {
            alert("Please save the photo first!");
            return;
        }

        const playStoreLink = appConfig.playStoreUrl;
        const message = "üìç Captured via GPS Map Camera Pro.\nDownload App: " + playStoreLink;

        try {
            if (window.Capacitor && Capacitor.Plugins && Capacitor.Plugins.Share) {
                await Capacitor.Plugins.Share.share({
                    title: "Share Field Report",
                    text: message,
                    url: LAST_SAVED_PHOTO_URI,
                    dialogTitle: "Share via WhatsApp"
                });
            } else {
                console.log("Sharing not supported in browser.");
                alert("Sharing works on Mobile App only.");
            }
        } catch (error) {
            console.error("Share Error:", error);
        }
    }

    /* =================================================================
       ADMOB & CONSENT LOGIC
       ================================================================= */
    async function requestUserConsent() {
        if (!window.Capacitor || !Capacitor.Plugins || !Capacitor.Plugins.AdMob) {
            return;
        }

        try {
            const { AdMob } = Capacitor.Plugins;
            const consentInfo = await AdMob.requestConsentInfo();

            if (consentInfo && consentInfo.isConsentFormAvailable && consentInfo.status === 'REQUIRED') {
                await AdMob.showConsentForm();
            }
        } catch (e) {
            console.warn("Consent error:", e);
        }
    }

    async function initializeAdMob() {
        if (!window.Capacitor) return;
        try {
            const { AdMob } = Capacitor.Plugins;
            AdMob.addListener('interstitialAdLoaded', () => { isInterstitialReady = true; });
            AdMob.addListener('interstitialAdDismissed', () => {
                isInterstitialReady = false;
                setTimeout(() => preloadNextInterstitial(), 5000);
            });
            AdMob.addListener('interstitialAdFailedToLoad', () => { isInterstitialReady = false; });

            await AdMob.initialize({ initializeForTesting: false });
            preloadNextInterstitial();
        } catch (e) { console.error("AdMob Init Error", e); }
    }

    async function preloadNextInterstitial() {
        if (!window.Capacitor || !Capacitor.Plugins || !Capacitor.Plugins.AdMob) return;

        try {
            const { AdMob } = Capacitor.Plugins;
            await AdMob.loadInterstitial({
                adId: 'ca-app-pub-7807602925578307/8272818556',
                isTesting: false
            });
            isInterstitialReady = true;
        } catch (e) {
            console.error("Interstitial load failed", e);
            isInterstitialReady = false;
        }
    }

    async function showBlockingInterstitialAd() {
        if (!window.Capacitor || !isInterstitialReady) return;
        try {
            await Capacitor.Plugins.AdMob.showInterstitial();
        } catch (e) {
            console.warn("Ad failed, continuing...", e);
        }
    }

    async function triggerBannerAd() {
        if (!window.Capacitor) return;
        try {
            const { AdMob } = Capacitor.Plugins;

            if (isBannerLoaded) {
                await AdMob.removeBanner();
                isBannerLoaded = false;
            }

            await AdMob.showBanner({
                adId: 'ca-app-pub-7807602925578307/5483003680',
                position: 'TOP_CENTER',
                margin: 35,
                size: 'BANNER',
                isTesting: false
            });

            isBannerLoaded = true;
        } catch (e) {
            console.error("Banner Fail", e);
            setTimeout(triggerBannerAd, 5000);
        }
    }

    /* =================================================================
       GOOGLE MAPS KEY (hidden-ish)
       ================================================================= */
    const __k1 = "QUl6YVN5Ql9YbHBQcHFKUmxT";
    const __k2 = "ZHZxbTRDSzd0OWhEQmJxN0oxcXB3";
    function __getKey() {
        const joined = (__k1 + __k2).split("").reverse().join("");
        return atob(joined.split("").reverse().join(""));
    }
    const GOOGLE_MAPS_API_KEY = (() => {
        try { return __getKey(); } catch { return ""; }
    })();

    /* =================================================================
       PERMISSIONS: CENTRALIZED CHECK & REQUEST
       ================================================================= */

    function waitForAppActive(timeout = 2200) {
        return new Promise(resolve => {
            let resolved = false;
            let handle = null;
            const cleanup = () => {
                if (resolved) return;
                resolved = true;
                try {
                    if (handle && handle.remove) handle.remove();
                } catch (e) { /* ignore */ }
                document.removeEventListener('visibilitychange', onVis);
                resolve();
            };

            const onVis = () => {
                if (document.visibilityState === 'visible') cleanup();
            };

            document.addEventListener('visibilitychange', onVis);

            try {
                if (window.Capacitor && Capacitor.Plugins && Capacitor.Plugins.App && Capacitor.Plugins.App.addListener) {
                    handle = Capacitor.Plugins.App.addListener('appStateChange', ({ isActive }) => {
                        if (isActive) cleanup();
                    });
                }
            } catch (e) {
                console.warn("App listener attach failed:", e);
            }

            // Fallback timeout
            setTimeout(() => { cleanup(); }, timeout);
        });
    }

    function _isGrantedValue(v) {
        if (!v && v !== "") return false;
        v = String(v).toLowerCase();
        return (v === 'granted' || v === 'limited' || v === 'granted:always' || v === 'granted_when_in_use' || v === 'granted:when_in_use');
    }

    async function checkAndRequestPermissions() {
        // Consolidated single source for permission checks across web & Capacitor
        let camOk = false, geoOk = false, mediaOk = false;

        // Browser path
        if (!window.Capacitor) {
            try {
                if (navigator.permissions) {
                    try {
                        const camPerm = await navigator.permissions.query({ name: 'camera' });
                        camOk = (camPerm.state === 'granted');
                    } catch (e) { /* ignore */ }

                    try {
                        const geoPerm = await navigator.permissions.query({ name: 'geolocation' });
                        geoOk = (geoPerm.state === 'granted');
                    } catch (e) { /* ignore */ }
                }

                if (!camOk && navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                    try {
                        await navigator.mediaDevices.getUserMedia({ video: true });
                        camOk = true;
                    } catch (e) { camOk = false; }
                }

                if (!geoOk && navigator.geolocation) {
                    await new Promise(res => {
                        navigator.geolocation.getCurrentPosition(() => { geoOk = true; res(); }, () => { geoOk = false; res(); }, { timeout: 5000 });
                    });
                }

                mediaOk = true;
                return { camera: camOk, geolocation: geoOk, media: mediaOk };
            } catch (e) {
                console.warn("Browser permission check failed", e);
                return { camera: camOk, geolocation: geoOk, media: mediaOk };
            }
        }

        // Capacitor/native path
        try {
            const Camera = Capacitor.Plugins?.Camera;
            const Geolocation = Capacitor.Plugins?.Geolocation;
            const Media = Capacitor.Plugins?.Media;

            // CAMERA
            if (Camera && Camera.requestPermissions) {
                try {
                    const camStatus = await Camera.requestPermissions();
                    if (camStatus) {
                        if (typeof camStatus === 'object') {
                            const v = camStatus.camera || camStatus.result || Object.values(camStatus)[0];
                            camOk = _isGrantedValue(v);
                        } else if (typeof camStatus === 'string') {
                            camOk = _isGrantedValue(camStatus);
                        }
                    }
                } catch (e) {
                    console.warn("Camera permission request failed:", e);
                }
            } else {
                try {
                    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                        await navigator.mediaDevices.getUserMedia({ video: true });
                        camOk = true;
                    }
                } catch (e) { camOk = false; }
            }

            // GEOLOCATION
            if (Geolocation && Geolocation.requestPermissions) {
                try {
                    const geoStatus = await Geolocation.requestPermissions();
                    if (geoStatus) {
                        if (typeof geoStatus === 'object') {
                            const v = geoStatus.location || geoStatus.result || Object.values(geoStatus)[0];
                            geoOk = _isGrantedValue(v);
                        } else if (typeof geoStatus === 'string') {
                            geoOk = _isGrantedValue(geoStatus);
                        } else {
                            geoOk = true;
                        }
                    } else {
                        geoOk = true;
                    }
                } catch (e) {
                    console.warn("Location permission request failed:", e);
                    geoOk = false;
                }
            } else {
                try {
                    await new Promise(res => {
                        navigator.geolocation.getCurrentPosition(() => { geoOk = true; res(); }, () => { geoOk = false; res(); }, { timeout: 6000 });
                    });
                } catch (e) { geoOk = false; }
            }

            // MEDIA / STORAGE
            if (Media && Media.requestPermissions) {
                try {
                    const mediaStatus = await Media.requestPermissions();
                    mediaOk = true;
                } catch (e) {
                    console.warn("Media permission request failed:", e);
                    mediaOk = false;
                }
            } else {
                mediaOk = true;
            }

            // Wait briefly for webview to regain focus/resume if native prompt was shown
            await waitForAppActive(1200);

            return { camera: camOk, geolocation: geoOk, media: mediaOk };
        } catch (err) {
            console.warn("checkAndRequestPermissions error:", err);
            return { camera: false, geolocation: false, media: false };
        }
    }

    async function ensureMediaPermission() {
        if (!window.Capacitor) return true;
        try {
            const Media = Capacitor.Plugins?.Media;
            if (Media && Media.requestPermissions) {
                try {
                    await Media.requestPermissions();
                    return true;
                } catch (e) {
                    console.warn("ensureMediaPermission failed:", e);
                    return false;
                }
            }
            return true;
        } catch (e) {
            console.warn("ensureMediaPermission error:", e);
            return false;
        }
    }

    /* =================================================================
       INITIALIZATION FLOW
       ================================================================= */

    async function handleStart() {
        try {
            console.log("User requested start - checking permissions...");
            const perms = await checkAndRequestPermissions();

            if (!perms.camera || !perms.geolocation) {
                alert("Required permissions were not granted. Please grant Camera and Location permissions.");
                const denied = el("denied-content"), permC = el("perm-content");
                if (denied && permC) {
                    permC.style.display = "none";
                    denied.style.display = "block";
                }
                return;
            }

            localStorage.setItem("policyAccepted", "true");
            localStorage.setItem("isReady", "true");

            const permScreen = el("perm-screen");
            if (permScreen) permScreen.style.display = "none";

            // Ensure app and webview are active before initializing hardware to avoid race/crash
            await waitForAppActive(2000);

            await initializeSystem();
        } catch (e) {
            alert("Error during startup: " + (e && e.message ? e.message : e));
            console.error("handleStart error", e);
        }
    }

    async function initializeSystem() {
        if (isSystemInitialized) return;
        isSystemInitialized = true;

        try {
            console.log("Permissions Received. Stabilizing System...");
            const statusEl = el("txt-status");
            if (statusEl) statusEl.innerText = "System Checking...";

            await new Promise(r => setTimeout(r, 1400));

            // Ensure video element present before starting camera
            let attempts = 0;
            while ((!video || video === null || !(video instanceof HTMLVideoElement)) && attempts < 8) {
                await new Promise(r => setTimeout(r, 200));
                attempts++;
            }

            const cameraStarted = await startCamera();
            if (!cameraStarted) {
                console.error("Camera failed to start.");
                if (statusEl) statusEl.innerText = "Camera Error";
                return;
            }

            startGPS();

            console.log("System Live.");

            if (window.Capacitor) {
                setTimeout(async () => {
                    try {
                        if (window.Capacitor.Plugins?.AdMob) {
                            await initializeAdMob();
                            triggerBannerAd();
                        }
                    } catch (e) {
                        console.warn("Delayed Ad init failed", e);
                    }
                }, 4000);
            }
        } catch (e) {
            console.error("Boot Error:", e);
        }
    }

    function safeResumeHardware() {
        try {
            if (!stream) startCamera();
            if (!watchId) startGPS();
        } catch (e) {
            console.warn("safeResumeHardware error", e);
        }
    }

    /* =================================================================
       HARDWARE: CAMERA MANAGEMENT ENGINE WITH RETRY
       ================================================================= */
    async function startCamera(retries = 3) {
        try {
            if (!video || !(video instanceof HTMLVideoElement)) {
                console.warn("Video element missing - cannot start camera");
                return false;
            }

            if (stream) {
                try { stream.getTracks().forEach(t => t.stop()); } catch (e) { console.warn("stop previous tracks failed", e); }
                stream = null;
            }

            const isHD = (el("chk-hd") && el("chk-hd").checked) ? true : false;

            const constraints = {
                video: {
                    facingMode: { ideal: facing },
                    aspectRatio: 4 / 3,
                    width: { ideal: isHD ? 1600 : 1280 },
                    height: { ideal: isHD ? 1200 : 960 },
                    frameRate: { ideal: 30 }
                },
                audio: false
            };

            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                throw new Error("getUserMedia not supported");
            }

            try {
                stream = await navigator.mediaDevices.getUserMedia(constraints);
            } catch (err) {
                console.warn("getUserMedia with facingMode failed, trying fallback without facingMode", err);
                const fallback = {
                    video: {
                        aspectRatio: 4 / 3,
                        width: { ideal: isHD ? 1600 : 1280 },
                        height: { ideal: isHD ? 1200 : 960 },
                        frameRate: { ideal: 30 }
                    },
                    audio: false
                };
                try {
                    stream = await navigator.mediaDevices.getUserMedia(fallback);
                } catch (err2) {
                    console.warn("Fallback getUserMedia also failed", err2);
                    stream = null;
                    throw err2;
                }
            }

            if (!stream) {
                throw new Error("No stream from getUserMedia");
            }

            // Strict safety: set srcObject only if video supports it
            try {
                if ('srcObject' in video) {
                    video.srcObject = stream;
                } else {
                    // Older fallback
                    video.src = window.URL.createObjectURL(stream);
                }
            } catch (e) {
                console.warn("Setting srcObject failed:", e);
            }

            track = stream.getVideoTracks()[0];
            if (video.classList) video.classList.toggle("mirrored", facing === "user");

            video.onloadedmetadata = () => {
                video.play().catch(e => console.log("Force play error", e));
            };
            video.style.display = "block";

            return true;
        } catch (e) {
            console.warn("Camera Error:", e);

            // Retry only for certain transient errors (race condition with permissions / webview)
            const transient = (e && e.name && (e.name === 'NotAllowedError' || e.name === 'NotReadableError' || e.name === 'OverconstrainedError'));
            if (retries > 0 && transient) {
                const waitMs = 600;
                console.log(`Transient camera error detected (${e.name}). Retrying in ${waitMs}ms (${retries - 1} retries left).`);
                await new Promise(r => setTimeout(r, waitMs));
                return startCamera(retries - 1);
            }

            // If HD was enabled, try to fallback to lower resolution once
            const hdEl = el("chk-hd");
            if (hdEl && hdEl.checked) {
                console.log("Retrying with Standard Quality...");
                hdEl.checked = false;
                return await startCamera(0);
            } else {
                const statusEl = el("txt-status");
                if (statusEl) statusEl.innerText = "Camera Error";
                console.error("Camera Error: Please restart app or check permissions.");
                return false;
            }
        }
    }

    /* =================================================================
       HARDWARE: SMART GPS ENGINE
       ================================================================= */
    function startGPS() {
        try {
            if (watchId) {
                try { navigator.geolocation.clearWatch(watchId); } catch (e) { console.warn("clearWatch failed", e); }
                watchId = null;
            }

            if (!navigator.geolocation) {
                const st = el("txt-status");
                if (st) st.innerText = "GPS Unavailable";
                return;
            }

            watchId = navigator.geolocation.watchPosition(async (pos) => {
                try {
                    accuracy = pos.coords.accuracy;
                    lat = pos.coords.latitude;
                    lon = pos.coords.longitude;
                    alt = pos.coords.altitude ? pos.coords.altitude.toFixed(1) + "m" : "0.0m";
                    speed = pos.coords.speed ? (pos.coords.speed * 3.6).toFixed(1) + " km/h" : "0 km/h";

                    if (pos.coords.heading !== null && !isNaN(pos.coords.heading)) {
                        heading = Math.round(pos.coords.heading) + "¬∞";
                    }

                    if (accuracy <= 15 && parseFloat(speed) <= 1) {
                        if (!window.__locationLocked) {
                            window.__locationLocked = true;
                            fetchReverseGeocode(lat, lon);
                            const st = el("txt-status");
                            if (st) st.innerText = "Location Locked";
                        }
                    }

                    const coordEl = el("txt-coords");
                    if (coordEl) coordEl.innerText = `${lat.toFixed(6)}, ${lon.toFixed(6)}`;

                    const sensorsEl = el("txt-sensors");
                    if (sensorsEl) sensorsEl.innerText = `${heading} | ${speed} | ${alt}`;

                    const accEl = el("txt-accuracy");
                    if (accEl) accEl.innerText = `Accuracy: ${Math.round(accuracy)} m`;

                    const now = Date.now();
                    const distMoved = calculateHaversine(lat, lon, lastLat, lastLon);
                    const minDistance = accSlider ? parseInt(accSlider.value || 30) : 30;
                    const minTimeMs = 60000;
                    const accuracyImproved = (accuracy < lastAccuracy - 5);

                    if (distMoved > minDistance || (now - lastApiTime) > minTimeMs || accuracyImproved) {
                        const limit = distSlider ? parseInt(distSlider.value || 30) : 30;
                        if (accuracy <= limit) {
                            if (accEl) accEl.className = "data-value status-good";
                            fetchReverseGeocode(lat, lon);
                            lastLat = lat;
                            lastLon = lon;
                            lastApiTime = now;
                            lastAccuracy = accuracy;
                        } else {
                            if (accEl) accEl.className = "data-value status-bad";
                        }
                    }
                } catch (innerErr) {
                    console.error("GPS watchPosition handler error:", innerErr);
                }
            }, (err) => {
                const st = el("txt-status");
                if (st) st.innerText = "GPS Signal Weak";
                console.warn("GPS watch error:", err);
            }, { enableHighAccuracy: true, maximumAge: 0, timeout: 10000 });
        } catch (e) {
            console.warn("startGPS error", e);
        }
    }

    function calculateHaversine(lat1, lon1, lat2, lon2) {
        const R = 6371e3;
        const phi1 = lat1 * Math.PI / 180;
        const phi2 = lat2 * Math.PI / 180;
        const deltaPhi = (lat2 - lat1) * Math.PI / 180;
        const deltaLambda = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(deltaPhi/2) * Math.sin(deltaPhi/2) +
                  Math.cos(phi1) * Math.cos(phi2) *
                  Math.sin(deltaLambda/2) * Math.sin(deltaLambda/2);
        return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    }

    async function isOnline() {
        if (!navigator.onLine) return false;
        try {
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), 2000);
            await fetch("https://www.google.com/favicon.ico", {
                method: "GET",
                signal: controller.signal,
                cache: "no-store",
                mode: 'no-cors'
            });
            clearTimeout(timeout);
            return true;
        } catch (e) {
            return true;
        }
    }

    async function fetchReverseGeocode(lt, ln) {
        try {
            if (!(await isOnline())) {
                address = `Offline Mode\nLat ${lt.toFixed(6)}, Lon ${ln.toFixed(6)}`;
                const addrEl = el("txt-address");
                const st = el("txt-status");
                if (addrEl) addrEl.innerText = address;
                if (st) st.innerText = "Offline Mode";
                return;
            }

            if (!GOOGLE_MAPS_API_KEY) {
                const addrEl = el("txt-address");
                if (addrEl) addrEl.innerText = `Lat ${lt.toFixed(6)}, Lon ${ln.toFixed(6)}`;
                const st = el("txt-status");
                if (st) st.innerText = "Maps Key Missing";
                return;
            }

            const res = await fetch(`https://maps.googleapis.com/maps/api/geocode/json?latlng=${lt},${ln}&key=${GOOGLE_MAPS_API_KEY}`);
            const data = await res.json();

            if (data && data.status === "OK" && Array.isArray(data.results) && data.results.length > 0) {
                let bestResult = data.results.find(r =>
                    r.types.includes("street_address") ||
                    r.types.includes("route") ||
                    r.types.includes("sublocality") ||
                    r.types.includes("locality")
                ) || data.results[0];

                address = bestResult.formatted_address || "";
                const addrEl = el("txt-address");
                if (addrEl) addrEl.innerText = address.length > 70 ? address.substring(0, 67) + "..." : address;
                const st = el("txt-status");
                if (st) st.innerText = "Location Verified";
            } else {
                const st = el("txt-status");
                if (st) st.innerText = "Address Unavailable";
            }
        } catch (err) {
            const addrEl = el("txt-address");
            const st = el("txt-status");
            if (addrEl) addrEl.innerText = `Lat ${lt.toFixed(6)}, Lon ${ln.toFixed(6)}`;
            if (st) st.innerText = "Network Error";
            console.warn("fetchReverseGeocode error:", err);
        }
    }

    /* =================================================================
       BUTTON LISTENERS & CAPTURE LOGIC
       ================================================================= */

    const toggleFlashBtn = el("toggle-flash");
    if (toggleFlashBtn) {
        toggleFlashBtn.onclick = async () => {
            if (!stream) {
                alert("Camera not active.");
                return;
            }
            const trackLocal = stream.getVideoTracks()[0];
            const btn = toggleFlashBtn;

            try {
                const capabilities = trackLocal.getCapabilities ? trackLocal.getCapabilities() : {};
                if (!capabilities.torch) {
                    alert("Flash unavailable on this lens.");
                    return;
                }

                const settingsLocal = trackLocal.getSettings ? trackLocal.getSettings() : {};
                const isFlashNowOn = !!settingsLocal.torch ? false : true;

                await trackLocal.applyConstraints({ advanced: [{ torch: isFlashNowOn }] });

                if (isFlashNowOn) {
                    btn.classList.add("flash-active");
                } else {
                    btn.classList.remove("flash-active");
                }
            } catch (e) {
                console.error("Flash Error:", e);
                btn.classList.remove("flash-active");
            }
        };
    }

    const switchCameraBtn = el("switch-camera");
    if (switchCameraBtn) {
        switchCameraBtn.onclick = async () => {
            if (!video) return;
            const btn = switchCameraBtn;

            if (video.classList) video.classList.add("camera-switching");
            btn.style.transition = "transform 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55)";
            btn.style.transform = "rotate(180deg)";

            setTimeout(async () => {
                try {
                    facing = facing === "user" ? "environment" : "user";
                    await startCamera();
                    if (facing === "user") {
                        if (video.classList) video.classList.add("mirrored");
                    } else {
                        if (video.classList) video.classList.remove("mirrored");
                    }
                } catch (e) {
                    console.error("Switch Error:", e);
                } finally {
                    if (video.classList) video.classList.remove("camera-switching");
                    setTimeout(() => {
                        btn.style.transition = "none";
                        btn.style.transform = "rotate(0deg)";
                    }, 500);
                }
            }, 300);
        };
    }

    const captureBtn = el("capture-btn");
    if (captureBtn) {
        captureBtn.onclick = () => {
            try {
                shutterAudio.play().catch(()=>{});
                if (!video || video.videoWidth === 0 || video.videoHeight === 0) return;

                const videoW = video.videoWidth;
                const videoH = video.videoHeight;
                if (!canvas || !ctx) return;

                canvas.width = videoW;
                canvas.height = videoH;

                if (facing === "user") {
                    ctx.save();
                    ctx.translate(canvas.width, 0);
                    ctx.scale(-1, 1);
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    ctx.restore();
                } else {
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                }

                if (el("chk-stamp") && el("chk-stamp").checked) {
                    const padding = Math.round(canvas.width * 0.04);
                    const cardW = canvas.width * 0.92;
                    const cardX = (canvas.width - cardW) / 2;
                    const mapSize = Math.round(canvas.width * 0.22);
                    const cardH = mapSize + (padding * 2);
                    const cardY = canvas.height - cardH - padding;
                    const mapX = cardX + padding;
                    const mapY = cardY + padding;

                    ctx.fillStyle = "rgba(0, 0, 0, 0.65)";
                    ctx.fillRect(cardX, cardY, cardW, cardH);

                    let isMapHandled = false;
                    const mapImg = new Image();
                    mapImg.crossOrigin = "anonymous";
                    mapImg.src = `https://maps.googleapis.com/maps/api/staticmap?center=${lat.toFixed(6)},${lon.toFixed(6)}&zoom=16&size=300x300&scale=2&maptype=roadmap&markers=color:red|${lat.toFixed(6)},${lon.toFixed(6)}&key=${GOOGLE_MAPS_API_KEY}`;

                    const mapTimeout = setTimeout(() => {
                        if (!isMapHandled) {
                            mapImg.onerror();
                        }
                    }, 5000);

                    mapImg.onload = () => {
                        if (isMapHandled) return;
                        isMapHandled = true;
                        clearTimeout(mapTimeout);
                        try { ctx.drawImage(mapImg, mapX, mapY, mapSize, mapSize); } catch (e) { console.warn("Map draw error", e); }
                        finishCapture(cardX, cardW, cardY, mapX, mapSize, mapY);
                    };

                    mapImg.onerror = () => {
                        if (isMapHandled) return;
                        isMapHandled = true;
                        clearTimeout(mapTimeout);

                        ctx.fillStyle = "#1a1a1a";
                        ctx.fillRect(mapX, mapY, mapSize, mapSize);
                        ctx.strokeStyle = "rgba(0, 230, 118, 0.2)";
                        ctx.lineWidth = 1;
                        ctx.strokeRect(mapX, mapY, mapSize, mapSize);

                        ctx.fillStyle = "#ff5252";
                        ctx.beginPath();
                        ctx.arc(mapX + mapSize / 2, mapY + mapSize / 2, 6, 0, 2 * Math.PI);
                        ctx.fill();

                        ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
                        ctx.font = "bold 10px sans-serif";
                        ctx.textAlign = "center";
                        ctx.fillText("OFFLINE", mapX + mapSize / 2, mapY + mapSize - 10);

                        finishCapture(cardX, cardW, cardY, mapX, mapSize, mapY);
                    };
                } else {
                    finishCapture(0, 0, 0, 0, 0, 0);
                }
            } catch (e) {
                console.error("Capture failed", e);
            }
        };
    }

    function finishCapture(cardX, cardW, cardY, mapX, mapSize, mapY) {
        try {
            if (!ctx) return;
            renderProWatermark(ctx, cardX, cardW, cardY, mapX, mapSize, mapY);

            const previewImg = el("photo-preview");
            if (previewImg && canvas) {
                previewImg.src = canvas.toDataURL("image/jpeg", 0.85);
                previewImg.style.display = "block";
            }

            if (saveModal) saveModal.classList.add("active");
            if (actionBar) actionBar.classList.remove("show");
        } catch (e) {
            console.error("finishCapture error:", e);
        }
    }

    function renderProWatermark(ctxLocal, cardX, cardW, cardY, mapX, mapSize, mapY) {
        if (!canvas) return;
        const baseFS = Math.max(10, Math.round(canvas.width * 0.032));
        const padding = 12 * (canvas.width / 1080);

        ctxLocal.textAlign = "right";
        ctxLocal.font = `bold ${Math.round(baseFS * 0.6)}px sans-serif`;
        ctxLocal.fillStyle = "rgba(255, 255, 255, 0.8)";
        ctxLocal.fillText("GPS Map Camera Pro", cardX + cardW - padding, cardY + (baseFS * 0.8));

        ctxLocal.textAlign = "left";
        const textX = mapX + mapSize + (15 * (canvas.width / 1080));
        let currentY = mapY + (baseFS * 0.8);

        ctxLocal.fillStyle = "#ffffff";
        ctxLocal.font = `bold ${Math.round(baseFS * 1.0)}px sans-serif`;

        const addrParts = (address || "").split(',');
        const city = addrParts[0] || "Unknown";
        const stateCountry = addrParts.length >= 2 ? addrParts.slice(-2).join(', ').trim() : "GPS Location";
        const availableWidth = (cardX + cardW) - textX - padding;

        ctxLocal.fillText(`${city} | ${stateCountry}`, textX, currentY, availableWidth);

        ctxLocal.font = `${Math.round(baseFS * 0.7)}px sans-serif`;
        currentY += baseFS * 1.1;
        ctxLocal.fillText((address || "Searching..."), textX, currentY, availableWidth);

        currentY += baseFS * 1.0;
        ctxLocal.fillText(`Lat ${lat.toFixed(6)} Long ${lon.toFixed(6)}`, textX, currentY);

        currentY += baseFS * 1.0;
        const now = new Date();
        const day = now.toLocaleDateString('en-IN', { weekday: 'long' });
        const dateStr = now.toLocaleDateString('en-GB');
        const timeStr = now.toLocaleTimeString('en-IN', { hour: '2-digit', minute: '2-digit', hour12: true });
        ctxLocal.fillText(`${day}, ${dateStr} | ${timeStr}`, textX, currentY);
    }

    /* =================================================================
       STORAGE: DCIM SAVING & SHARING
       ================================================================= */
    const btnSave = el("btn-save");
    if (btnSave) {
        btnSave.onclick = async () => {
            const saveBtn = btnSave;
            const originalText = saveBtn.innerText;
            saveBtn.innerText = "Saving...";
            saveBtn.disabled = true;

            try {
                if (!canvas) throw new Error("No canvas to save from");

                const dataUrl = canvas.toDataURL("image/jpeg", 0.95);
                const base64Data = dataUrl.replace(/^data:image\/jpeg;base64,/, "");
                saveToGalleryDB(base64Data);             
                const fileName = `GPS_PRO_${Date.now()}.jpg`;
                const ALBUM_NAME = "GPS_Map_Camera";

                if (window.Capacitor) {
                    const { Filesystem, Media } = Capacitor.Plugins;

                    try {
                        const okMedia = await ensureMediaPermission();
                        if (!okMedia) throw new Error("Media permission denied");
                    } catch (e) {
                        throw e;
                    }

                    const temp = await Filesystem.writeFile({
                        path: fileName,
                        data: base64Data,
                        directory: "CACHE"
                    });

                    const fileUri = temp.uri && temp.uri.startsWith("file://") ? temp.uri : `file://${temp.uri}`;

                    let albumId;
                    try {
                        const album = await Media.createAlbum({ name: ALBUM_NAME });
                        albumId = album && album.identifier;
                    } catch (e) {
                        try {
                            const albums = await Media.getAlbums();
                            const existing = albums && albums.albums ? albums.albums.find(a => a.name === ALBUM_NAME) : null;
                            albumId = existing && existing.identifier;
                        } catch (ee) {
                            console.warn("Album creation/fetch error", ee);
                        }
                    }

                    await Media.savePhoto({
                        path: fileUri,
                        albumIdentifier: albumId
                    });
                    LAST_SAVED_PHOTO_URI = fileUri;

                    if (window.Capacitor?.Plugins?.AdMob) {
                        try { await showBlockingInterstitialAd(); } catch (e) { console.warn("Interstitial not ready"); }
                    }

                    const saveOverlay = el("save-modal-overlay");
                    if (saveOverlay) saveOverlay.classList.remove("active");
                    setTimeout(() => {
                        const successModal = el("success-modal");
                        if (successModal) successModal.classList.add("active");
                    }, 500);
                } else {
                    const a = document.createElement('a');
                    a.href = dataUrl;
                    a.download = fileName;
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                    alert("Saved to browser download folder.");
                }
            } catch (err) {
                alert("Save failed: " + (err && err.message ? err.message : err));
                console.error(err);
            } finally {
                saveBtn.innerText = originalText;
                saveBtn.disabled = false;
            }
        };
    }

    /* =================================================================
       UI & LIFECYCLE
       ================================================================= */

    const btnCloseBar = el("btn-close-bar");
    if (btnCloseBar) {
        btnCloseBar.onclick = () => {
            const ab = el("action-bar");
            if (ab) ab.classList.remove("show");
        };
    }

    async function showManualAlert(Dialog) {
        if (Dialog) {
            try {
                await Dialog.alert({
                    title: 'Check Folder',
                    message: 'Gallery open ‡§®‡§π‡•Ä‡§Ç ‡§π‡•ã ‡§∏‡§ï‡•Ä. Photo ‡§Ø‡§π‡§æ‡§Å ‡§π‡•à: \nDCIM/GPS_Map_Camera',
                    buttonTitle: 'Close'
                });
            } catch (e) {
                alert("Check folder: DCIM/GPS_Map_Camera");
            }
        } else { alert("Check folder: DCIM/GPS_Map_Camera"); }
    }

    const chkHd = el("chk-hd");
    if (chkHd) chkHd.onchange = () => { startCamera(); };

    const openSettingsBtn = el("open-settings");
    if (openSettingsBtn) openSettingsBtn.onclick = () => {
        const sp = el("settings-panel");
        if (sp) sp.classList.add("active");
    };

    const closeSettingsBtn = el("close-settings");
    if (closeSettingsBtn) closeSettingsBtn.onclick = () => {
        const sp = el("settings-panel");
        if (sp) sp.classList.remove("active");
    };

    if (accSlider && accLabel) accSlider.oninput = () => { accLabel.innerText = accSlider.value + "m"; };
    if (distSlider && distLabel) distSlider.oninput = () => { distLabel.innerText = distSlider.value + "m"; };

    document.addEventListener("keydown", (e) => {
        if (e.keyCode === 24 || e.keyCode === 25 || e.code === "VolumeUp" || e.code === "VolumeDown") {
            e.preventDefault();
            const capBtn = el("capture-btn");
            if (capBtn) capBtn.click();
        }
    });

    document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
            if (stream) {
                try { stream.getTracks().forEach(t => t.stop()); } catch(e){ console.warn("stop tracks on hidden failed", e); }
                stream = null;
            }
            if (watchId) {
                try { navigator.geolocation.clearWatch(watchId); } catch (e) { console.warn("clearWatch failed", e); }
                watchId = null;
            }
        } else {
            if (localStorage.getItem("isReady") === "true" && isSystemInitialized) {
                console.log("Resuming Hardware...");
                safeResumeHardware();
            }
        }
    });

    setInterval(() => {
        const t = el("txt-time");
        if (t) t.innerText = new Date().toLocaleString('hi-IN');
    }, 1000);

    window.addEventListener("load", () => {
        let pct = 0;
        const pctEl = el('progress-percent');
        if (pctEl) {
            const interval = setInterval(() => {
                pct += 10;
                if (pct > 100) pct = 100;
                pctEl.innerText = pct + "%";
                if (pct === 100) clearInterval(interval);
            }, 150);
        }

        const items = ['item-gps', 'item-map', 'item-cam', 'item-secure'];
        items.forEach((id, i) => {
            setTimeout(() => {
                const element = el(id);
                if (element) {
                    element.classList.add('active');
                    const icon = element.querySelector('.status-icon');
                    if (icon) icon.innerText = "check_circle";
                    element.style.color = '#00e676';
                }
            }, 300 + (i * 300));
        });

        setTimeout(() => {
            const splash = el("intro-splash");
            const screen = el("perm-screen");

            if (localStorage.getItem("isReady") === "true") {
                if (splash) splash.style.display = "none";
                if (screen) screen.style.display = "none";
                initializeSystem().catch(e => console.error("init on load failed", e));
            } else {
                if (splash) splash.style.display = "none";
                if (screen) screen.style.display = "flex";
            }
        }, 2500);
    });

    function isHomeScreenAuto() {
        if (document.querySelector(".modal-overlay.active")) return false;

        const settingsModal = el("settings-panel");
        if (settingsModal && settingsModal.classList.contains("active")) return false;

        const saveOverlay = el("save-modal-overlay");
        if (saveOverlay && saveOverlay.classList.contains("active")) return false;

        const photoPreview = el("photo-preview");
        if (photoPreview && photoPreview.style.display === "block") return false;

        if (!video || video.readyState < 2) return false;

        const style = window.getComputedStyle(video);
        if (style.display === "none" || style.visibility === "hidden") return false;

        return true;
    }

    document.addEventListener("backbutton", () => {
        if (!isHomeScreenAuto()) {
            const modal = document.querySelector(".modal-overlay.active");
            if (modal) { modal.classList.remove("active"); return; }

            const saveOverlay = el("save-modal-overlay");
            if (saveOverlay && saveOverlay.classList.contains("active")) {
                saveOverlay.classList.remove("active");
                return;
            }

            const settings = el("settings-panel");
            if (settings && settings.classList.contains("active")) {
                settings.classList.remove("active");
                return;
            }

            return;
        }

        if (window.Capacitor?.Plugins?.Dialog) {
            try {
                Capacitor.Plugins.Dialog.confirm({
                    title: "Exit App",
                    message: "Do you want to close the app?",
                    okButtonTitle: "Yes",
                    cancelButtonTitle: "No"
                }).then(result => {
                    if (result.value) {
                        try { navigator.app.exitApp(); } catch (e) { /* ignore */ }
                    }
                });
            } catch (e) {
                if (confirm("Do you want to close the app?")) {
                    try { navigator.app.exitApp(); } catch (x) { /* ignore */ }
                }
            }
        } else {
            if (confirm("Do you want to close the app?")) {
                try { navigator.app.exitApp(); } catch (e) { /* ignore */ }
            }
        }
    });

    const btnDiscard = el("btn-discard");
    if (btnDiscard) {
        btnDiscard.onclick = () => {
            const saveOverlay = el("save-modal-overlay");
            if (saveOverlay) saveOverlay.classList.remove("active");

            const previewImg = el("photo-preview");
            if (previewImg) {
                previewImg.src = "";
                previewImg.style.display = "none";
            }

            if (canvas && ctx) {
                try { ctx.clearRect(0, 0, canvas.width, canvas.height); } catch (e) { console.warn("clear canvas failed", e); }
            }

            const actionBarEl = el("action-bar");
            if (actionBarEl) actionBarEl.classList.remove("show");
        };
    }

    const btnStart = el("btn-start");
    if (btnStart) btnStart.onclick = handleStart;

    const btnRetryPermissions = el("btn-retry-permissions");
    if (btnRetryPermissions) btnRetryPermissions.onclick = () => {
        const denied = el("denied-content"), permC = el("perm-content");
        if (denied && permC) {
            denied.style.display = "none";
            permC.style.display = "block";
        }
    };

    const shareSuccessBtn = el("share-success-btn");
    if (shareSuccessBtn) shareSuccessBtn.onclick = shareOnWhatsApp;
    const closeSuccessBtnEl = el("close-success-btn");
    if (closeSuccessBtnEl) closeSuccessBtnEl.onclick = () => {
        const successModalEl = el("success-modal");
        if (successModalEl) successModalEl.classList.remove("active");
    };

    const btnShareWhatsapp = el("btn-share-whatsapp");
    if (btnShareWhatsapp) btnShareWhatsapp.onclick = shareOnWhatsApp;
const DB_NAME = "GPSCamDB";
const STORE_NAME = "photos";
let db;

const request = indexedDB.open(DB_NAME, 1);
request.onupgradeneeded = (e) => {
    e.target.result.createObjectStore(STORE_NAME, { keyPath: "id", autoIncrement: true });
};
request.onsuccess = (e) => {
    db = e.target.result;
};

function saveToGalleryDB(base64Data) {
    if (!db) return;
    const transaction = db.transaction([STORE_NAME], "readwrite");
    const store = transaction.objectStore(STORE_NAME);
    const photo = {
        data: base64Data,
        date: new Date().toLocaleString(),
        timestamp: Date.now()
    };
    store.add(photo);
}

function loadGalleryImages() {
    const grid = el("gallery-grid");
    const emptyMsg = el("gallery-empty");
    grid.innerHTML = "";
    
    if (!db) return;
    const transaction = db.transaction([STORE_NAME], "readonly");
    const store = transaction.objectStore(STORE_NAME);
    const req = store.getAll();

    req.onsuccess = () => {
        const photos = req.result.reverse();
        
        if (photos.length === 0) {
            emptyMsg.style.display = "block";
        } else {
            emptyMsg.style.display = "none";
            photos.forEach(photo => {
                const div = document.createElement("div");
                div.className = "gallery-item";
                
                const img = document.createElement("img");
                img.src = "data:image/jpeg;base64," + photo.data;
                
                div.onclick = () => openViewer(photo.id, photo.data);
                div.appendChild(img);
                grid.appendChild(div);
            });
        }
    };
}

let currentPhotoId = null;
function openViewer(id, data) {
    el("viewer-img").src = "data:image/jpeg;base64," + data;
    el("viewer-modal").classList.add("active");
    currentPhotoId = id;
}

const openGalleryBtn = el("open-gallery");
if(openGalleryBtn) {
    openGalleryBtn.onclick = () => {
        el("gallery-modal").classList.add("active");
        loadGalleryImages();
    };
}

const closeGalleryBtn = el("close-gallery");
if(closeGalleryBtn) {
    closeGalleryBtn.onclick = () => el("gallery-modal").classList.remove("active");
}

const closeViewerBtn = el("btn-close-viewer");
if(closeViewerBtn) {
    closeViewerBtn.onclick = () => el("viewer-modal").classList.remove("active");
}

const deletePhotoBtn = el("btn-delete-photo");
if(deletePhotoBtn) {
    deletePhotoBtn.onclick = () => {
        if (!currentPhotoId || !db) return;
        if(confirm("Delete this photo?")) {
            const transaction = db.transaction([STORE_NAME], "readwrite");
            transaction.objectStore(STORE_NAME).delete(currentPhotoId);
            transaction.oncomplete = () => {
                el("viewer-modal").classList.remove("active");
                loadGalleryImages();
            };
        }
    };
}
// --- GALLERY SHARE LOGIC ---
const shareGalleryBtn = el("btn-share-gallery");
if (shareGalleryBtn) {
    shareGalleryBtn.onclick = async () => {
        const imgEl = el("viewer-img");
        if (!imgEl || !imgEl.src) return;

        try {
            const base64 = imgEl.src.split(',')[1];
            const binary = atob(base64);
            const array = [];
            for (let i = 0; i < binary.length; i++) {
                array.push(binary.charCodeAt(i));
            }
            const blob = new Blob([new Uint8Array(array)], { type: 'image/jpeg' });
            const file = new File([blob], "gps_camera_photo.jpg", { type: 'image/jpeg' });

            if (navigator.share) {
                await navigator.share({
                    files: [file],
                    title: 'Field Report',
                    text: 'Photo captured via GPS Map Camera'
                });
            } else {
                alert("Share feature not supported on this device/browser.");
            }
        } catch (e) {
            console.error("Gallery Share Error:", e);
            alert("Unable to share this photo.");
        }
    };
}

    /* =================================================================
       CENTRALIZED APP RESUME/FOCUS HANDLER (avoid duplicates)
       ================================================================= */
    (function registerAppResumeHandler() {
        try {
            if (window.Capacitor && Capacitor.Plugins && Capacitor.Plugins.App && Capacitor.Plugins.App.addListener) {
                Capacitor.Plugins.App.addListener('appStateChange', ({ isActive }) => {
                    if (isActive) {
                        if (localStorage.getItem("policyAccepted") === "true" &&
                            localStorage.getItem("isReady") === "true") {
                            if (!isSystemInitialized) {
                                initializeSystem().catch(e => console.warn("Initialize on resume failed", e));
                            } else {
                                safeResumeHardware();
                            }
                        }
                    }
                });
            } else {
                document.addEventListener("resume", () => {
                    if (localStorage.getItem("policyAccepted") === "true" &&
                        localStorage.getItem("isReady") === "true") {
                        if (!isSystemInitialized) {
                            initializeSystem().catch(e => console.warn("Initialize on resume failed", e));
                        } else {
                            safeResumeHardware();
                        }
                    }
                });
            }
        } catch (e) {
            console.warn("registerAppResumeHandler error:", e);
        }
    })();

</script>
</body>
</html>
