<!DOCTYPE html>
<html lang="hi">
<head>
    <!--
      FIXES APPLIED (summary):
      - Ensured UTF-8 meta charset is present and used (was present).
      - Replaced corrupted emoji sequences (e.g., "Ã°Å¸â€˜Ë†") with correct Unicode characters or removed them.
      - Fixed corrupted degree symbol in initial sensor text (was "0Ã¯Â¿Â½", now "0Â°").
      - Removed unsafe automatic location.reload() that caused race-conditions/crashes after first-time permission grant.
        Instead we now safely call initializeSystem() after permissions are requested and add more robust permission result handling.
      - Added null checks before using DOM elements to prevent NullReference errors.
      - Improved permission request handling to tolerate different Capacitor return shapes and to avoid unhandled cases.
      - Consolidated duplicated refs and small refactors (helper function el()).
      - Fixed some minor mistakes and ensured all functions guard against missing resources.
      - Preserved original app logic while making it safe and robust to first-time permission acceptance.
    -->

    <meta charset="utf-8">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <title>GPS Map Camera - Ultra Pro Max (Official Final Build)</title>
    <meta name="description" content="GPS Map Camera app to capture photos with real-time GPS location, address, latitude longitude and map watermark. Camera with location stamp for survey and inspection.">
    <meta name="keywords" content="gps map camera, camera with gps location, gps photo camera, location camera app, geo tag camera, camera with location stamp, gps coordinates camera, map camera gps">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#000000">

    <style>
        /* CSS ROOT VARIABLES */
        :root {
            --primary-color: #00e676; /* WhatsApp & Success Green */
            --secondary-color: #1e88e5; /* Professional Field Blue */
            --danger-color: #ff5252; /* Error/Alert Red */
            --dark-bg: #000000;
            --overlay-bg: rgba(0, 0, 0, 0.82);
            --text-color: #ffffff;
            --glass-border: rgba(255, 255, 255, 0.18);
            --font-main: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            --shadow-heavy: 0 15px 55px rgba(0, 0, 0, 0.85);
        }

        /* -----------------------------------------------------------------
           CORE SYSTEM RESET & PERFORMANCE OPTIMIZATION
           ----------------------------------------------------------------- */
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            outline: none;
            margin: 0;
            padding: 0;
        }

        body {
            background: var(--dark-bg);
            color: var(--text-color);
            font-family: var(--font-main);
            overflow: hidden;
            user-select: none;
            height: 100vh;
            width: 100vw;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        /* -----------------------------------------------------------------
           VISUAL HARDWARE LAYERS (VIDEO & PROCESSING CANVAS)
           ----------------------------------------------------------------- */
        #video-preview, #capture-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: black;
            z-index: 1;
        }

        /* Smooth Camera Switch Animation */
        .camera-switching {
            opacity: 0;
            transform: scale(0.95);
            filter: blur(15px);
            transition: all 0.4s ease-in-out;
        }

        #video-preview {
            transition: transform 0.5s ease, opacity 0.4s ease;
        }

        #capture-canvas {
            display: none; /* Internal processing only */
        }

        /* Front camera mirroring logic */
        .mirrored {
            transform: scaleX(-1);
        }

        /* -----------------------------------------------------------------
           GEOTAG HUD OVERLAY (REAL-TIME DATA DASHBOARD)
           ----------------------------------------------------------------- */
        #data-overlay {
            position: absolute;
            bottom: 25px;         /* niche se sahi balance */
            left: 15px;
            width: 260px;         /* Width ko restrict kiya */
            max-height: 150px;    /* Height ko restrict kiya */
            background: rgba(0, 0, 0, 0.4); /* Professional transparent black */
            backdrop-filter: blur(10px);    /* Premium glass look */
            border: 1px solid rgba(255, 255, 255, 0.15); /* Patli professional border */
            border-radius: 10px;
            padding: 10px;
            color: #fff;
            font-size: 10.5px;    /* Chota aur saaf font */
            overflow: hidden;     /* Text box se bahar nahi jayega */
            z-index: 15;
            pointer-events: none; /* Screen touch mein disturb nahi karega */
        }

        /* Address line ke liye special fix */
        #data-overlay .address-line {
            white-space: normal;  /* Lamba address line change karega */
            display: -webkit-box;
            -webkit-line-clamp: 2; /* Sirf 2 lines dikhayega agar bahut bada address ho */
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .data-row {
            font-size: 11px; /* Font chota kiya */
            display: flex;
            align-items: flex-start;
            gap: 8px;
        }

        .data-label {
            font-weight: bold;
            width: 20px;
            text-align: center;
            font-size: 12px;
            opacity: 0.9;
        }

        .data-value {
            color: #f2f2f2;
            flex: 1;
            line-height: 1.6;
            letter-spacing: 0.3px;
        }

        /* Accuracy Color Coding Logic */
        .status-good {
            color: var(--primary-color);
            font-weight: 900;
            text-shadow: 0 0 10px rgba(0, 230, 118, 0.3);
        }

        .status-bad {
            color: var(--danger-color);
            font-weight: 900;
            text-shadow: 0 0 10px rgba(255, 82, 82, 0.3);
        }

        /* -----------------------------------------------------------------
           FLOATING INTERFACE CONTROLS
           ----------------------------------------------------------------- */
        .btn-circle {
            position: fixed;
            width: 68px;
            height: 68px;
            border-radius: 50%;
            border: none;
            background: var(--secondary-color);
            color: white;
            font-size: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.65);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .btn-circle:active {
            transform: scale(0.82);
            filter: brightness(1.2);
        }

        #capture-btn {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 80px;
            border-radius: 50%;
            z-index: 25;
            /* Premium Metallic Gradient */
            background: linear-gradient(145deg, #ffffff, #b0bec5);
            /* Ring Border */
            border: 5px solid rgba(255, 255, 255, 0.3);
            /* 3D Depth Effect (Shadows) */
            box-shadow:
                0 10px 25px rgba(0,0,0,0.5),
                inset 0 2px 4px rgba(255,255,255,0.9),
                inset 0 -3px 6px rgba(0,0,0,0.2);
            cursor: pointer;
        }

        /* Click karne par thoda dabne ka effect */
        #capture-btn:active {
            transform: translateX(-50%) scale(0.95);
            background: linear-gradient(145deg, #b0bec5, #ffffff);
        }

        /* Precise positioning for tooltips */
        /* --- Professional Layout: Buttons in Corners --- */
        #switch-camera {
            position: fixed;
            right: 18px;          /* same vertical line */
            bottom: 250px;
            width: 52px;
            height: 52px;
            border-radius: 50%;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
            border: 1.5px solid rgba(255,255,255,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        #toggle-flash {
            position: fixed;
            right: 18px;          /* same as settings */
            bottom: 180px;
            width: 52px;
            height: 52px;
            border-radius: 50%;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
            border: 1.5px solid rgba(255,255,255,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        /* Flash ON Active State */
        .flash-active {
            background: rgba(255, 215, 0, 0.3) !important;
            border: 2px solid #FFD700 !important;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.8), inset 0 0 10px #FFD700 !important;
            transform: scale(1.1) !important;
            color: #FFD700 !important;
        }

        #open-settings {
            position: fixed;
            right: 18px;          /* reference vertical line */
            bottom: 110px;
            width: 52px;
            height: 52px;
            border-radius: 50%;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
            border: 1.5px solid rgba(255,255,255,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        /* -----------------------------------------------------------------
           AAPKA UPDATED HERO BUTTON
           ----------------------------------------------------------------- */
        .hero-btn {
            padding: 22px 80px;
            border-radius: 50px;
            border: none;
            background: var(--primary-color);
            font-weight: 900;
            font-size: 22px;
            color: #000;
            box-shadow: 0 15px 45px rgba(0, 230, 118, 0.45);
            cursor: pointer;
            transition: transform 0.3s;
        }
        .hero-btn:active { transform: scale(0.92); }

        /* --- User Policy Box Design --- */
        .policy-box {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--glass-border);
            border-radius: 15px;
            padding: 15px;
            margin: 20px 0;
            max-height: 180px;
            overflow-y: auto;
            text-align: left;
            font-size: 12px;
            line-height: 1.5;
            color: #ccc;
        }
        .policy-check {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            margin-bottom: 25px;
            color: #fff;
            font-size: 14px;
        }
        .policy-check input {
            width: 20px;
            height: 20px;
            accent-color: var(--primary-color);
        }

        /* -----------------------------------------------------------------
           SETTINGS DRAWER (SLIDE-UP)
           ----------------------------------------------------------------- */
        /* Line 265 ke paas is block ko update karein */
        #settings-panel {
            position: fixed;
            bottom: -100%;
            left: 0;
            width: 100%;
            background: #161616;
            border-radius: 38px 38px 0 0;
            padding: 40px 30px 80px 30px; /* Niche 80px padding add ki hai */
            z-index: 10000 !important;   /* Isse panel hamesha sabse upar rahega */
            transition: bottom 0.5s cubic-bezier(0.2, 1, 0.3, 1);
            border-top: 5px solid var(--primary-color);
        }

        #settings-panel.active {
            bottom: 0;
        }

        .setting-header {
            margin-top: 0;
            color: var(--primary-color);
            font-size: 24px;
            margin-bottom: 30px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 28px;
        }

        .toggle-label { font-size: 16px; font-weight: 500; }

        input[type=range] {
            width: 140px;
            accent-color: var(--primary-color);
        }

        /* -----------------------------------------------------------------
           ANIMATED MODAL (SAVE CONFIRMATION)
           ----------------------------------------------------------------- */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px);
            z-index: 3000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s ease-out;
        }

        .modal-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .modal-box {
            background: #1c1c1c;
            border: 1px solid var(--glass-border);
            padding: 45px 35px;
            border-radius: 45px;
            text-align: center;
            width: 92%;
            max-width: 400px;
            box-shadow: 0 45px 90px rgba(0,0,0,0.95);
            transform: scale(0.65) translateY(70px);
            opacity: 0;
            transition: all 0.55s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .modal-overlay.active .modal-box {
            transform: scale(1) translateY(0);
            opacity: 1;
        }

        .modal-title {
            color: var(--primary-color);
            font-size: 26px;
            margin: 15px 0 10px 0;
        }

        .modal-body {
            color: #b0b0b0;
            line-height: 1.6;
            margin-bottom: 35px;
            font-size: 16px;
        }

        .modal-footer {
            display: flex;
            gap: 20px;
        }

        .modal-btn {
            flex: 1;
            padding: 20px;
            border: none;
            border-radius: 22px;
            font-weight: 900;
            font-size: 17px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .modal-btn:active { transform: scale(0.94); }

        .btn-save { background: var(--primary-color); color: #000; box-shadow: 0 8px 25px rgba(0, 230, 118, 0.25); }
        .btn-discard { background: #333; color: #fff; }

        /* -----------------------------------------------------------------
           DYNAMIC ACTION BAR (OPEN & SHARE)
           ----------------------------------------------------------------- */
        #action-bar {
            position: fixed;
            bottom: -150px;
            left: 20px;
            right: 20px;
            background: #141414;
            border-radius: 30px;
            padding: 20px;
            z-index: 4000;
            display: flex;
            gap: 18px;
            transition: bottom 0.75s cubic-bezier(0.18, 0.89, 0.32, 1.28);
            border: 1.5px solid var(--primary-color);
            box-shadow: 0 25px 60px rgba(0, 230, 118, 0.35);
        }

        #action-bar.show {
            bottom: 35px;
        }

        .action-btn {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            padding: 18px;
            border: none;
            border-radius: 22px;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
        }

        .btn-open { background: #2a2a2a; color: white; }
        .btn-whatsapp { background: #25D366; color: white; }

        /* -----------------------------------------------------------------
           ONBOARDING / PERMISSION SCREEN
           ----------------------------------------------------------------- */
        #perm-screen {
            position: fixed;
            inset: 0;
            background: #000;
            z-index: 5000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 45px;
        }

        .hero-title {
            color: var(--primary-color);
            font-size: 40px;
            margin: 0 0 20px 0;
            text-shadow: 0 0 20px rgba(0, 230, 118, 0.4);
        }

        .hero-desc {
            color: #777;
            font-size: 18px;
            margin-bottom: 50px;
            max-width: 300px;
            line-height: 1.6;
        }

        /* =========================================
           ULTIMATE HUD STYLES
           ========================================= */
        #intro-splash {
            position: fixed; inset: 0;
            background: #000;
            z-index: 99999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            font-family: 'Segoe UI', monospace; /* Monospace for Tech feel */
            overflow: hidden;
        }

        /* Cyber Grid Background */
        .grid-bg {
            position: absolute; width: 200%; height: 200%;
            background-image:
                linear-gradient(rgba(0, 255, 136, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 136, 0.05) 1px, transparent 1px);
            background-size: 50px 50px;
            transform: perspective(500px) rotateX(60deg) translateY(-100px) translateZ(-200px);
            animation: grid-move 10s linear infinite;
            opacity: 0.6;
        }
        @keyframes grid-move { 0% {transform: perspective(500px) rotateX(60deg) translateY(0);} 100% {transform: perspective(500px) rotateX(60deg) translateY(50px);} }

        /* HUD RADAR SYSTEM */
        .hud-container {
            position: relative; width: 140px; height: 140px;
            display: flex; align-items: center; justify-content: center;
            margin-bottom: 30px;
        }
        .app-icon { font-size: 50px; z-index: 10; animation: icon-pulse 2s infinite; }

        /* Rings Animation */
        .hud-ring {
            position: absolute; border-radius: 50%;
            border: 1px solid rgba(0, 230, 118, 0.3);
            box-shadow: 0 0 10px rgba(0, 230, 118, 0.1);
        }
        .outer { width: 100%; height: 100%; border-top-color: #00e676; border-bottom-color: #00e676; animation: spin-cw 4s linear infinite; }
        .middle { width: 75%; height: 75%; border-left-color: #00e676; border-right-color: #00e676; animation: spin-ccw 3s linear infinite; }
        .inner { width: 50%; height: 50%; border: 2px dashed rgba(0, 230, 118, 0.6); animation: spin-cw 5s linear infinite; }
        .hud-scan-line {
            position: absolute; width: 100%; height: 2px; background: #00e676;
            box-shadow: 0 0 10px #00e676;
            animation: radar-scan 2s linear infinite;
            opacity: 0.7;
        }

        @keyframes spin-cw { 100% { transform: rotate(360deg); } }
        @keyframes spin-ccw { 100% { transform: rotate(-360deg); } }
        @keyframes radar-scan { 0% {top:0%; opacity:0;} 50% {opacity:1;} 100% {top:100%; opacity:0;} }

        /* Typography */
        .splash-title {
            color: #fff; font-size: 28px; font-weight: 800; letter-spacing: 2px;
            margin-bottom: 30px; z-index: 2;
            text-shadow: 0 0 20px rgba(0, 230, 118, 0.4);
        }
        .pro-badge {
            background: #00e676; color: #000; padding: 2px 6px; border-radius: 4px;
            font-size: 14px; vertical-align: middle;
        }

        /* SYSTEM CHECK LIST */
        .system-check-list {
            width: 280px; margin-bottom: 30px; z-index: 2;
        }
        .check-item {
            display: flex; align-items: center; gap: 15px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            color: #888; font-size: 13px;
            transition: all 0.3s;
        }
        .check-item.active { color: #fff; text-shadow: 0 0 5px #00e676; }
        .status-icon { width: 15px; text-align: center; }

        /* Progress */
        .progress-container {
            width: 240px; display: flex; align-items: center; gap: 10px; z-index: 2;
        }
        .progress-bar {
            flex: 1; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; position: relative;
            overflow: hidden;
        }
        .progress-bar::after {
            content: ''; position: absolute; left: 0; top: 0; height: 100%; width: 0%;
            background: #00e676;
            animation: progress-fill 3.2s cubic-bezier(0.22, 1, 0.36, 1) forwards;
            box-shadow: 0 0 10px #00e676;
        }
        #progress-percent { color: #00e676; font-size: 12px; font-weight: bold; width: 35px; }

        .loading-status {
            margin-top: 15px; font-size: 10px; color: #555; letter-spacing: 3px; z-index: 2;
        }

        @keyframes progress-fill { 0%{width:0%} 100%{width:100%} }

    </style>
</head>

<body>
<div id="intro-splash">
    <div class="grid-bg"></div>

    <div class="hud-container">
        <div class="hud-ring outer"></div>
        <div class="hud-ring middle"></div>
        <div class="hud-ring inner"></div>
        <div class="hud-scan-line"></div>
        <div class="app-icon material-icons">gps_fixed</div>
    </div>

    <h1 class="splash-title">GPS CAMERA <span class="pro-badge">PRO</span></h1>

    <div class="system-check-list">
        <div class="check-item" id="item-gps">
            <span class="status-icon material-icons">check_circle</span>
            <span class="status-text">Calibrating GPS Sensors...</span>
        </div>
        <div class="check-item" id="item-map">
            <span class="status-icon material-icons">check_circle</span>
            <span class="status-text">Loading Map Overlay...</span>
        </div>
        <div class="check-item" id="item-cam">
            <span class="status-icon material-icons">check_circle</span>
            <span class="status-text">Initializing 4K Lens...</span>
        </div>
        <div class="check-item" id="item-secure">
            <span class="status-icon material-icons">check_circle</span>
            <span class="status-text">Verifying Secure Storage...</span>
        </div>
    </div>

    <div class="progress-container">
        <div class="progress-bar"></div>
        <span id="progress-percent">0%</span>
    </div>

    <p class="loading-status">SYSTEM BOOT SEQUENCE INITIATED</p>
</div>

<video id="video-preview" autoplay playsinline></video>
<canvas id="capture-canvas" style="display:none"></canvas>

<div id="data-overlay">
    <!-- STATUS -->
    <div class="data-row">
        <span class="data-label material-icons">location_on</span>
        <span id="txt-status" class="data-value">Initializing Sensors...</span>
    </div>

    <!-- COORDINATES -->
    <div class="data-row">
        <span class="data-label material-icons">public</span>
        <span id="txt-coords" class="data-value">0.000000, 0.000000</span>
    </div>

    <!-- ADDRESS -->
    <div class="data-row">
        <span class="data-label material-icons">home</span>
        <span id="txt-address" class="data-value">Searching Location...</span>
    </div>

    <!-- SENSORS -->
    <div class="data-row">
        <span class="data-label material-icons">explore</span>
        <span id="txt-sensors" class="data-value">0Â° | 0 km/h | 0.0m</span>
    </div>

    <!-- ACCURACY -->
    <div class="data-row">
        <span class="data-label material-icons">straighten</span>
        <span id="txt-accuracy" class="data-value status-bad">Accuracy Calibration...</span>
    </div>

    <!-- TIME -->
    <div class="data-row">
        <span class="data-label material-icons">schedule</span>
        <span id="txt-time" class="data-value">--/--/----, --:-- am/pm</span>
    </div>
</div>

<button id="switch-camera" class="btn-circle material-icons" title="Switch Lens">cameraswitch</button>
<button id="toggle-flash" class="btn-circle material-icons" title="Toggle Light">flash_on</button>
<button id="open-settings" class="btn-circle material-icons" title="Settings">settings</button>
<button id="capture-btn" title="Capture Geotagged Image"></button>

<div id="action-bar">
    <button id="btn-share-whatsapp" class="action-btn btn-whatsapp material-icons">share</button>
    <button id="btn-close-bar" class="material-icons">close</button>
</div>

<div id="save-modal-overlay" class="modal-overlay">
    <div class="modal-box">
        <img id="photo-preview"
             style="width: 100%; max-height: 320px; object-fit: contain; background: #000; border-radius: 20px; margin-bottom: 22px; display: none;" />
        <h2 class="modal-title" style="letter-spacing: 0.5px;">Field Report Generated</h2>
        <p class="modal-body" style="font-size: 15px; color: #ccc;">
            Geotagged documentation captured successfully. <br>
            Verify location data and confirm to save.
        </p>
        <div class="modal-footer">
            <button id="btn-discard" class="modal-btn btn-discard">Discard</button>
            <button id="btn-save" class="modal-btn btn-save">Confirm & Save</button>
        </div>
    </div>
</div>

<div id="success-modal" class="modal-overlay" style="z-index: 20002;">
    <div class="modal-box" style="background: #1c1c1c; border: 1px solid var(--primary-color); text-align: center; max-width: 300px;">
        <div style="margin-bottom: 15px;">
            <span class="material-icons" style="font-size: 55px; color: var(--primary-color); text-shadow: 0 0 15px rgba(0,230,118,0.4);">check_circle</span>
        </div>

        <h2 style="color: #fff; font-size: 20px; margin-bottom: 8px;">Saved Successfully</h2>
        <p style="color: #aaa; font-size: 13px; margin-bottom: 25px;">
            Photo Gallery mein save ho gayi hai.
        </p>

        <div class="modal-footer" style="flex-direction: column; gap: 10px;">
            <button id="share-success-btn" class="modal-btn" style="background: #25D366; color: white; display: flex; align-items: center; justify-content: center; gap: 8px; width: 100%;">Share</button>
            <button id="close-success-btn" class="modal-btn" style="background: #333; color: #fff; width: 100%;">Close / Band Karein</button>
        </div>
    </div>
</div>

<div id="settings-panel">
    <h2 class="setting-header">Pro Configurations</h2>
    <div class="setting-item">
        <span class="toggle-label">Accuracy Limit: <b id="lbl-acc-limit">50m</b></span>
        <input id="rng-accuracy" type="range" min="10" max="250" step="5" value="50">
    </div>
    <div class="setting-item">
        <span class="toggle-label">Distance Throttle: <b id="lbl-dist-limit">30m</b></span>
        <input id="rng-distance" type="range" min="10" max="150" step="10" value="30">
    </div>
    <div class="setting-item">
        <span class="toggle-label">Enable Watermark Stamp</span>
        <input id="chk-stamp" type="checkbox" style="width:25px; height:25px;" checked>
    </div>
    <div class="setting-item">
        <span class="toggle-label">High-Res Mode (1080p)</span>
        <input id="chk-hd" type="checkbox" style="width:25px; height:25px;" checked>
    </div>

    <button id="close-settings" style="width:100%; padding:18px; background:#333; color:white; border:none; border-radius:20px; font-weight:bold; margin-top:20px; cursor:pointer;">Theek Hai</button>
</div>

<div id="perm-screen">
    <h1 class="hero-title">GPS Map Camera</h1>
    <p class="hero-desc" id="perm-status">Professional Field Survey Tool</p>

    <div id="perm-content">
        <div class="policy-box">
            <b style="color:var(--primary-color);">Permissions Required:</b><br><br>
            1. <b>Camera:</b> Documentation capture ke liye.<br>
            2. <b>GPS:</b> Real-time location stamping ke liye.<br>
            3. <b>Storage:</b> Photos ko gallery mein save karne ke liye.
        </div>
        <button class="hero-btn" id="btn-start">Accept & Initialize</button>
    </div>

    <div id="denied-content" style="display:none;">
        <p style="color:var(--danger-color); margin-bottom:20px;">Permissions Denied! <br> App bina sensors ke kaam nahi karegi.</p>
        <button class="hero-btn" id="btn-retry-permissions" style="background:var(--danger-color);">Try Again / Grant Access</button>
    </div>
</div>

<script>
    /* =================================================================
       GLOBAL VARIABLES & CONFIGURATION
       ================================================================= */

    // Helper: safe element getter
    function el(id) { return document.getElementById(id); }

    let isSystemInitialized = false;
    let LAST_SAVED_PHOTO_URI = "";

    document.addEventListener("resume", () => {
        console.log("App resumed");

        if (localStorage.getItem("policyAccepted") === "true" &&
            localStorage.getItem("isReady") === "true") {
            // Protect against double-initialize
            if (!isSystemInitialized) {
                initializeSystem().catch(e => console.warn("Initialize on resume failed", e));
            } else {
                // restart hardware safely
                safeResumeHardware();
            }
        }
    });

    // Global Hardware Variables
    let stream = null;
    let track = null;
    let facing = "environment";
    let watchId = null;
    let settingsClickCount = 0;

    // AdMob State Variables
    let isInterstitialReady = false;
    let isBannerLoaded = false;

    // Smart API Throttling Variables
    let lastLat = 0;
    let lastLon = 0;
    let lastApiTime = 0;

    // GPS & Sensor Data placeholders
    let lat = 0;
    let lon = 0;
    let alt = "0m";
    let speed = "0 km/h";
    let accuracy = 999;
    let lastAccuracy = 999;
    let heading = "0Â°";
    let address = "Searching Location...";

    // DOM ELEMENTS CACHE (use el() to avoid errors if missing)
    const video = el("video-preview");
    const canvas = el("capture-canvas");
    const ctx = canvas ? canvas.getContext("2d") : null;
    const actionBar = el("action-bar");
    const saveModal = el("save-modal-overlay");
    const accSlider = el("rng-accuracy");
    const accLabel = el("lbl-acc-limit");
    const distSlider = el("rng-distance");
    const distLabel = el("lbl-dist-limit");

    // Shutter Audio (Fixed Base64 to prevent error)
    const shutterAudio = new Audio("data:audio/wav;base64,UklGRiIAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA=");

    // APPLICATION CONFIGURATION
    const appConfig = {
        applicationId: "com.ravi.gpscamera",
        get playStoreUrl() { return `https://play.google.com/store/apps/details?id=${this.applicationId}`; }
    };

    /* =================================================================
       HELPER FUNCTIONS
       ================================================================= */
    function safeText(str) {
        if (!str && str !== "") return "";
        try {
            // Normalize and remove control chars only (preserve emoji / other unicode)
            str = String(str).normalize('NFC');
            // Remove C0/C1 control characters except common whitespace
            return str.replace(/\p{C}/gu, '').trim();
        } catch (e) {
            // Fallback: simple ASCII-filter
            return String(str).replace(/[^\x20-\x7E\u00A0-\uFFFF]/g, '');
        }
    }

    function closeSuccessModal() {
        const modal = el("success-modal");
        if (modal) {
            modal.classList.remove("active");
        }
    }

    // WHATSAPP SHARE FUNCTION WITH PLAY STORE LINK
    async function shareOnWhatsApp() {
        if (!LAST_SAVED_PHOTO_URI) {
            alert("Please save the photo first!");
            return;
        }

        const playStoreLink = appConfig.playStoreUrl;
        const message = "ðŸ“ Captured via GPS Map Camera Pro.\nDownload App: " + playStoreLink;

        try {
            if (window.Capacitor && Capacitor.Plugins && Capacitor.Plugins.Share) {
                await Capacitor.Plugins.Share.share({
                    title: "Share Field Report",
                    text: message,
                    url: LAST_SAVED_PHOTO_URI,
                    dialogTitle: "Share via WhatsApp"
                });
            } else {
                console.log("Sharing not supported in browser.");
                alert("Sharing works on Mobile App only.");
            }
        } catch (error) {
            console.error("Share Error:", error);
        }
    }

    /* =================================================================
       ADMOB & CONSENT LOGIC
       ================================================================= */
    async function requestUserConsent() {
        if (!window.Capacitor || !Capacitor.Plugins || !Capacitor.Plugins.AdMob) {
            return;
        }

        try {
            const { AdMob } = Capacitor.Plugins;
            const consentInfo = await AdMob.requestConsentInfo();

            if (consentInfo && consentInfo.isConsentFormAvailable && consentInfo.status === 'REQUIRED') {
                await AdMob.showConsentForm();
            }
        } catch (e) {
            console.warn("Consent error:", e);
        }
    }

    async function initializeAdMob() {
        if (!window.Capacitor) return;
        try {
            const { AdMob } = Capacitor.Plugins;
            AdMob.addListener('interstitialAdLoaded', () => { isInterstitialReady = true; });
            AdMob.addListener('interstitialAdDismissed', () => {
                isInterstitialReady = false;
                setTimeout(() => preloadNextInterstitial(), 5000);
            });

            AdMob.addListener('interstitialAdFailedToLoad', () => { isInterstitialReady = false; });

            await AdMob.initialize({ initializeForTesting: false });
            preloadNextInterstitial();
        } catch (e) { console.error("AdMob Init Error", e); }
    }

    async function preloadNextInterstitial() {
        if (!window.Capacitor || !Capacitor.Plugins || !Capacitor.Plugins.AdMob) return;

        try {
            const { AdMob } = Capacitor.Plugins;
            await AdMob.loadInterstitial({
                adId: 'ca-app-pub-7807602925578307/8272818556',
                isTesting: false
            });
            isInterstitialReady = true;
        } catch (e) {
            console.error("Interstitial load failed", e);
            isInterstitialReady = false;
        }
    }

    async function showBlockingInterstitialAd() {
        if (!window.Capacitor || !isInterstitialReady) return;
        try {
            await Capacitor.Plugins.AdMob.showInterstitial();
        } catch (e) {
            console.warn("Ad failed, continuing...", e);
        }
    }

    async function triggerBannerAd() {
        if (!window.Capacitor) return;
        try {
            const { AdMob } = Capacitor.Plugins;

            if (isBannerLoaded) {
                await AdMob.removeBanner();
                isBannerLoaded = false;
            }

            await AdMob.showBanner({
                adId: 'ca-app-pub-7807602925578307/5483003680',
                position: 'TOP_CENTER',
                margin: 35,
                size: 'BANNER',
                isTesting: false
            });

            isBannerLoaded = true;
        } catch (e) {
            console.error("Banner Fail", e);
            setTimeout(triggerBannerAd, 5000);
        }
    }

    if (window.Capacitor) {
        try {
            window.Capacitor.Plugins.App.addListener('appStateChange', ({ isActive }) => {
                if (isActive) triggerBannerAd();
            });
        } catch (e) { console.warn("App listener unavailable", e); }
    }

    /* =================================================================
       GOOGLE MAPS API â€“ HARDENED SECURITY
       ================================================================= */
    const __k1 = "QUl6YVN5Ql9YbHBQcHFKUmxT";
    const __k2 = "ZHZxbTRDSzd0OWhEQmJxN0oxcXB3";

    function __getKey() {
        const joined = (__k1 + __k2).split("").reverse().join("");
        return atob(joined.split("").reverse().join(""));
    }

    const GOOGLE_MAPS_API_KEY = (() => {
        try {
            return __getKey();
        } catch {
            return "";
        }
    })();

    /* =================================================================
       PERMISSIONS: CENTRALIZED CHECK & REQUEST
       ================================================================= */

    // Wait until the app/webview stabilizes after native permission prompts
    function waitForAppResume(timeout = 1500) {
        return new Promise(resolve => {
            let resolved = false;
            const clean = () => {
                if (resolved) return;
                resolved = true;
                try {
                    if (window.Capacitor && Capacitor.removeListener) Capacitor.removeListener('appStateChange', onAppStateChange);
                } catch (e) { /* ignore */ }
                resolve();
            };

            const onAppStateChange = ({ isActive }) => {
                if (isActive) clean();
            };

            // Listen for Capacitor app state change if available
            try {
                if (window.Capacitor && Capacitor.Plugins && Capacitor.Plugins.App && Capacitor.Plugins.App.addListener) {
                    Capacitor.Plugins.App.addListener('appStateChange', onAppStateChange);
                }
            } catch (e) { /* ignore */ }

            // Fallback timeout
            setTimeout(clean, timeout);
        });
    }

    // Normalize permission response value -> true if 'granted' or 'limited'
    function _isGrantedValue(v) {
        if (!v && v !== "") return false;
        v = String(v).toLowerCase();
        return (v === 'granted' || v === 'limited' || v === 'granted:always' || v === 'granted_when_in_use');
    }

    // Single robust function to check & request Camera / Location / Media permissions
    async function checkAndRequestPermissions() {
        let camOk = false, geoOk = false, mediaOk = false;

        // Browser path: try to use navigator.permissions where available
        if (!window.Capacitor) {
            try {
                // Camera
                if (navigator.permissions) {
                    try {
                        const camPerm = await navigator.permissions.query({ name: 'camera' });
                        camOk = (camPerm.state === 'granted');
                    } catch (e) { /* ignore */ }

                    try {
                        const geoPerm = await navigator.permissions.query({ name: 'geolocation' });
                        geoOk = (geoPerm.state === 'granted');
                    } catch (e) { /* ignore */ }
                }

                // If not granted, prompt via getUserMedia / geolocation to request
                if (!camOk) {
                    try {
                        await navigator.mediaDevices.getUserMedia({ video: true });
                        camOk = true;
                    } catch (e) { camOk = false; }
                }

                if (!geoOk && navigator.geolocation) {
                    await new Promise(res => {
                        navigator.geolocation.getCurrentPosition(() => { geoOk = true; res(); }, () => { geoOk = false; res(); }, { timeout: 5000 });
                    });
                }

                mediaOk = true; // Browser typically allows downloads; assume OK
                return { camera: camOk, geolocation: geoOk, media: mediaOk };
            } catch (e) {
                console.warn("Browser permission check failed", e);
                return { camera: camOk, geolocation: geoOk, media: mediaOk };
            }
        }

        // Capacitor native path
        try {
            const Camera = Capacitor.Plugins.Camera;
            const Geolocation = Capacitor.Plugins.Geolocation;
            const Media = Capacitor.Plugins.Media;

            // CAMERA
            if (Camera && Camera.requestPermissions) {
                try {
                    const camStatus = await Camera.requestPermissions();
                    if (camStatus) {
                        if (typeof camStatus === 'object') {
                            const v = camStatus.camera || camStatus.result || Object.values(camStatus)[0];
                            camOk = _isGrantedValue(v);
                        } else if (typeof camStatus === 'string') {
                            camOk = _isGrantedValue(camStatus);
                        }
                    }
                } catch (e) {
                    console.warn("Camera permission request failed:", e);
                }
            } else {
                // Fallback: try to open getUserMedia quickly to prompt
                try {
                    await navigator.mediaDevices.getUserMedia({ video: true });
                    camOk = true;
                } catch (e) { camOk = false; }
            }

            // GEOLOCATION
            if (Geolocation && Geolocation.requestPermissions) {
                try {
                    const geoStatus = await Geolocation.requestPermissions();
                    if (geoStatus) {
                        if (typeof geoStatus === 'object') {
                            const v = geoStatus.location || geoStatus.result || Object.values(geoStatus)[0];
                            geoOk = _isGrantedValue(v);
                        } else if (typeof geoStatus === 'string') {
                            geoOk = _isGrantedValue(geoStatus);
                        } else {
                            // If no clear returned value, assume granted unless exception thrown
                            geoOk = true;
                        }
                    } else {
                        geoOk = true; // assume granted
                    }
                } catch (e) {
                    console.warn("Location permission request failed:", e);
                    geoOk = false;
                }
            } else {
                // Fallback: prompt once via navigator.geolocation
                try {
                    await new Promise(res => {
                        navigator.geolocation.getCurrentPosition(() => { geoOk = true; res(); }, () => { geoOk = false; res(); }, { timeout: 6000 });
                    });
                } catch (e) { geoOk = false; }
            }

            // MEDIA / STORAGE
            if (Media && Media.requestPermissions) {
                try {
                    const mediaStatus = await Media.requestPermissions();
                    if (mediaStatus) {
                        if (typeof mediaStatus === 'object') {
                            const v = mediaStatus.result || Object.values(mediaStatus)[0];
                            mediaOk = _isGrantedValue(v) || true; // many platforms return nothing meaningful for storage; treat permissive
                        } else {
                            mediaOk = true;
                        }
                    } else {
                        mediaOk = true;
                    }
                } catch (e) {
                    console.warn("Media permission request failed:", e);
                    mediaOk = false;
                }
            } else {
                mediaOk = true; // if plugin missing, assume native path will permit saving
            }

            // Wait briefly for webview to regain focus/resume if native prompt was shown
            await waitForAppResume(1200);

            return { camera: camOk, geolocation: geoOk, media: mediaOk };

        } catch (err) {
            console.warn("checkAndRequestPermissions error:", err);
            // conservative fallback
            return { camera: false, geolocation: false, media: false };
        }
    }

    // ensure media permission helper used by save flow
    async function ensureMediaPermission() {
        if (!window.Capacitor) return true;
        try {
            const Media = Capacitor.Plugins.Media;
            if (Media && Media.requestPermissions) {
                try {
                    const s = await Media.requestPermissions();
                    // ignore complex return shapes for media; return true if no exception
                    return true;
                } catch (e) {
                    console.warn("ensureMediaPermission failed:", e);
                    return false;
                }
            }
            return true;
        } catch (e) {
            console.warn("ensureMediaPermission error:", e);
            return false;
        }
    }

    /* =================================================================
       INITIALIZATION FLOW
       ================================================================= */

    /*
      handleStart:
      - Use centralized permissions request.
      - Only initialize system when critical permissions granted.
      - Do NOT force a reload.
    */
    async function handleStart() {
        try {
            console.log("User requested start - checking permissions...");

            // Request & normalize permissions
            const perms = await checkAndRequestPermissions();

            // Require camera and geolocation explicitly
            if (!perms.camera || !perms.geolocation) {
                alert("Required permissions were not granted. Please grant Camera and Location permissions.");
                const denied = el("denied-content"), permC = el("perm-content");
                if (denied && permC) {
                    permC.style.display = "none";
                    denied.style.display = "block";
                }
                return;
            }

            // Save policy and readiness only after permissions accepted
            localStorage.setItem("policyAccepted", "true");
            localStorage.setItem("isReady", "true");

            // Hide permission screen safely
            const permScreen = el("perm-screen");
            if (permScreen) permScreen.style.display = "none";

            // Stabilize the webview (native permission dialog may have caused lifecycle changes)
            await waitForAppResume(800);

            // Start initialization
            await initializeSystem();

        } catch (e) {
            alert("Error during startup: " + (e && e.message ? e.message : e));
            console.error("handleStart error", e);
        }
    }

    async function initializeSystem() {
        if (isSystemInitialized) return;
        isSystemInitialized = true;

        try {
            console.log("Permissions Received. Stabilizing System...");

            const statusEl = el("txt-status");
            if (statusEl) statusEl.innerText = "System Checking...";

            // SAFETY DELAY (2 SECONDS) to allow DOM & hardware to settle
            await new Promise(r => setTimeout(r, 2000));

            // Ensure video element present and visible before starting camera
            let attempts = 0;
            while ((!video || video === null) && attempts < 6) {
                await new Promise(r => setTimeout(r, 200));
                attempts++;
            }

            // Start camera and GPS, but check for element availability
            const cameraStarted = await startCamera();
            if (!cameraStarted) {
                console.error("Camera failed to start.");
                if (statusEl) statusEl.innerText = "Camera Error";
                return;
            }
            startGPS();

            console.log("System Live.");

            // ADS LOAD (4 sec baad)
            if (window.Capacitor) {
                setTimeout(async () => {
                    try {
                        if (window.Capacitor.Plugins?.AdMob) {
                            await initializeAdMob();
                            triggerBannerAd();
                        }
                    } catch (e) {}
                }, 4000);
            }
        } catch (e) {
            console.error("Boot Error:", e);
        }
    }

    function safeResumeHardware() {
        // When app resumes and the system is already initialized,
        // attempt to re-acquire hardware safely.
        try {
            if (!stream) startCamera();
            if (!watchId) startGPS();
        } catch (e) {
            console.warn("safeResumeHardware error", e);
        }
    }

    /* =================================================================
       HARDWARE: CAMERA MANAGEMENT ENGINE
       ================================================================= */
    async function startCamera() {
        try {
            if (!video) {
                console.warn("Video element missing - cannot start camera");
                return false;
            }

            // Cleanup previous streams if they exist
            if (stream) {
                try { stream.getTracks().forEach(t => t.stop()); } catch (e) { /* ignore */ }
                stream = null;
            }

            const isHD = el("chk-hd") ? el("chk-hd").checked : false;

            let constraints = {
                video: {
                    facingMode: { ideal: facing }, // safer: ideal
                    aspectRatio: 4 / 3,
                    width: { ideal: isHD ? 1600 : 1280 },
                    height: { ideal: isHD ? 1200 : 960 },
                    frameRate: { ideal: 30 }
                },
                audio: false
            };

            try {
                stream = await navigator.mediaDevices.getUserMedia(constraints);
            } catch (err) {
                console.warn("getUserMedia with facingMode failed, trying fallback without facingMode", err);
                const fallback = {
                    video: {
                        aspectRatio: 4 / 3,
                        width: { ideal: isHD ? 1600 : 1280 },
                        height: { ideal: isHD ? 1200 : 960 },
                        frameRate: { ideal: 30 }
                    },
                    audio: false
                };
                try {
                    stream = await navigator.mediaDevices.getUserMedia(fallback);
                } catch (err2) {
                    console.warn("Fallback getUserMedia also failed", err2);
                    stream = null;
                }
            }

            if (!stream) {
                throw new Error("No stream from getUserMedia");
            }

            video.srcObject = stream;
            track = stream.getVideoTracks()[0];
            if (video.classList) video.classList.toggle("mirrored", facing === "user");

            video.onloadedmetadata = () => {
                video.play().catch(e => console.log("Force play error", e));
            };
            video.style.display = "block";

            return true;

        } catch (e) {
            console.warn("Camera Error:", e);

            // Retry Logic (Standard Quality Fallback)
            const hdEl = el("chk-hd");
            if (hdEl && hdEl.checked) {
                console.log("Retrying with Standard Quality...");
                hdEl.checked = false;
                return await startCamera();
            } else {
                const statusEl = el("txt-status");
                if (statusEl) statusEl.innerText = "Camera Error";
                // Avoid aggressive alerts that cause app to block after native prompts
                console.error("Camera Error: Please restart app or check permissions.");
                return false;
            }
        }
    }

    /* =================================================================
       HARDWARE: SMART GPS ENGINE
       ================================================================= */
    function startGPS() {
        try {
            if (watchId) {
                try { navigator.geolocation.clearWatch(watchId); } catch (e) { /* ignore */ }
                watchId = null;
            }

            if (!navigator.geolocation) {
                const st = el("txt-status");
                if (st) st.innerText = "GPS Unavailable";
                return;
            }

            watchId = navigator.geolocation.watchPosition(async (pos) => {
                accuracy = pos.coords.accuracy;
                lat = pos.coords.latitude;
                lon = pos.coords.longitude;
                alt = pos.coords.altitude ? pos.coords.altitude.toFixed(1) + "m" : "0.0m";
                speed = pos.coords.speed ? (pos.coords.speed * 3.6).toFixed(1) + " km/h" : "0 km/h";

                if (pos.coords.heading !== null && !isNaN(pos.coords.heading)) {
                    heading = Math.round(pos.coords.heading) + "Â°";
                }

                // HARD LOCATION LOCK
                if (accuracy <= 15 && parseFloat(speed) <= 1) {
                    if (!window.__locationLocked) {
                        window.__locationLocked = true;
                        fetchReverseGeocode(lat, lon);
                        const st = el("txt-status");
                        if (st) st.innerText = "Location Locked";
                    }
                }

                const coordEl = el("txt-coords");
                if (coordEl) coordEl.innerText = `${lat.toFixed(6)}, ${lon.toFixed(6)}`;

                const sensorsEl = el("txt-sensors");
                if (sensorsEl) sensorsEl.innerText = `${heading} | ${speed} | ${alt}`;

                const accEl = el("txt-accuracy");
                if (accEl) accEl.innerText = `Accuracy: ${Math.round(accuracy)} m`;

                // SMART THROTTLE CHECK
                const now = Date.now();
                const distMoved = calculateHaversine(lat, lon, lastLat, lastLon);
                const minDistance = accSlider ? parseInt(accSlider.value || 30) : 30;
                const minTimeMs = 60000;
                const accuracyImproved = (accuracy < lastAccuracy - 5);

                if (distMoved > minDistance || (now - lastApiTime) > minTimeMs || accuracyImproved) {
                    const limit = distSlider ? parseInt(distSlider.value || 30) : 30;
                    if (accuracy <= limit) {
                        if (accEl) accEl.className = "data-value status-good";
                        fetchReverseGeocode(lat, lon);
                        lastLat = lat;
                        lastLon = lon;
                        lastApiTime = now;
                        lastAccuracy = accuracy;
                    } else {
                        if (accEl) accEl.className = "data-value status-bad";
                    }
                }

            }, (err) => {
                const st = el("txt-status");
                if (st) st.innerText = "GPS Signal Weak";
            }, { enableHighAccuracy: true, maximumAge: 0, timeout: 10000 });
        } catch (e) {
            console.warn("startGPS error", e);
        }
    }

    function calculateHaversine(lat1, lon1, lat2, lon2) {
        const R = 6371e3; // Earth radius in meters
        const phi1 = lat1 * Math.PI / 180;
        const phi2 = lat2 * Math.PI / 180;
        const deltaPhi = (lat2 - lat1) * Math.PI / 180;
        const deltaLambda = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(deltaPhi/2) * Math.sin(deltaPhi/2) +
                  Math.cos(phi1) * Math.cos(phi2) *
                  Math.sin(deltaLambda/2) * Math.sin(deltaLambda/2);
        return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    }

    // REAL INTERNET CHECK
    async function isOnline() {
        if (!navigator.onLine) return false;
        try {
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), 2000);
            // Note: mode:'no-cors' will often succeed without readable response; we only want to see if fetch completes
            await fetch("https://www.google.com/favicon.ico", {
                method: "GET",
                signal: controller.signal,
                cache: "no-store",
                mode: 'no-cors'
            });
            clearTimeout(timeout);
            return true;
        } catch (e) {
            // Fallback: assume online (don't block map attempts)
            return true;
        }
    }

    async function fetchReverseGeocode(lt, ln) {
        try {
            if (!(await isOnline())) {
                address = `Offline Mode\nLat ${lt.toFixed(6)}, Lon ${ln.toFixed(6)}`;
                const addrEl = el("txt-address");
                const st = el("txt-status");
                if (addrEl) addrEl.innerText = address;
                if (st) st.innerText = "Offline Mode";
                return;
            }

            if (!GOOGLE_MAPS_API_KEY) {
                const addrEl = el("txt-address");
                if (addrEl) addrEl.innerText = `Lat ${lt.toFixed(6)}, Lon ${ln.toFixed(6)}`;
                const st = el("txt-status");
                if (st) st.innerText = "Maps Key Missing";
                return;
            }

            const res = await fetch(
                `https://maps.googleapis.com/maps/api/geocode/json?latlng=${lt},${ln}&key=${GOOGLE_MAPS_API_KEY}`
            );
            const data = await res.json();

            if (data && data.status === "OK" && Array.isArray(data.results) && data.results.length > 0) {
                let bestResult = data.results.find(r =>
                    r.types.includes("street_address") ||
                    r.types.includes("route") ||
                    r.types.includes("sublocality") ||
                    r.types.includes("locality")
                ) || data.results[0];

                address = bestResult.formatted_address;
                const addrEl = el("txt-address");
                if (addrEl) addrEl.innerText = address.length > 70 ? address.substring(0, 67) + "..." : address;
                const st = el("txt-status");
                if (st) st.innerText = "Location Verified";
            } else {
                const st = el("txt-status");
                if (st) st.innerText = "Address Unavailable";
            }
        } catch (err) {
            const addrEl = el("txt-address");
            const st = el("txt-status");
            if (addrEl) addrEl.innerText = `Lat ${lt.toFixed(6)}, Lon ${ln.toFixed(6)}`;
            if (st) st.innerText = "Network Error";
        }
    }

    /* =================================================================
       ADVANCED BUTTON LISTENERS (ANIMATIONS & LOGIC)
       ================================================================= */

    // TORCH / FLASH LOGIC
    const toggleFlashBtn = el("toggle-flash");
    if (toggleFlashBtn) {
        toggleFlashBtn.onclick = async () => {
            if (!stream) {
                alert("Camera not active.");
                return;
            }
            const trackLocal = stream.getVideoTracks()[0];
            const btn = toggleFlashBtn;

            try {
                const capabilities = trackLocal.getCapabilities ? trackLocal.getCapabilities() : {};
                if (!capabilities.torch) {
                    alert("Flash unavailable on this lens.");
                    return;
                }

                const settingsLocal = trackLocal.getSettings ? trackLocal.getSettings() : {};
                const isFlashNowOn = !!settingsLocal.torch ? false : true;

                await trackLocal.applyConstraints({
                    advanced: [{ torch: isFlashNowOn }]
                });

                if (isFlashNowOn) {
                    btn.classList.add("flash-active");
                } else {
                    btn.classList.remove("flash-active");
                }
            } catch (e) {
                console.error("Flash Error:", e);
                btn.classList.remove("flash-active");
            }
        };
    }

    // PRO CAMERA SWITCH LOGIC
    const switchCameraBtn = el("switch-camera");
    if (switchCameraBtn) {
        switchCameraBtn.onclick = async () => {
            if (!video) return;
            const btn = switchCameraBtn;

            // Visual Effect Start
            if (video.classList) video.classList.add("camera-switching");
            btn.style.transition = "transform 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55)";
            btn.style.transform = "rotate(180deg)";

            setTimeout(async () => {
                try {
                    // Mode Switch
                    facing = facing === "user" ? "environment" : "user";
                    // Restart camera
                    await startCamera();
                    // Mirror Class
                    if (facing === "user") {
                        if (video.classList) video.classList.add("mirrored");
                    } else {
                        if (video.classList) video.classList.remove("mirrored");
                    }
                } catch (e) {
                    console.error("Switch Error:", e);
                } finally {
                    if (video.classList) video.classList.remove("camera-switching");
                    setTimeout(() => {
                        btn.style.transition = "none";
                        btn.style.transform = "rotate(0deg)";
                    }, 500);
                }
            }, 300);
        };
    }

    // CAPTURE BUTTON LOGIC
    const captureBtn = el("capture-btn");
    if (captureBtn) {
        captureBtn.onclick = () => {
            try {
                shutterAudio.play().catch(()=>{});
                if (!video || video.videoWidth === 0 || video.videoHeight === 0) return;

                // Setup Canvas
                const videoW = video.videoWidth;
                const videoH = video.videoHeight;
                if (!canvas || !ctx) return;

                canvas.width = videoW;
                canvas.height = videoH;

                // Draw Camera Frame
                if (facing === "user") {
                    ctx.save();
                    ctx.translate(canvas.width, 0);
                    ctx.scale(-1, 1);
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    ctx.restore();
                } else {
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                }

                // WATERMARK LOGIC
                if (el("chk-stamp") && el("chk-stamp").checked) {

                    const padding = Math.round(canvas.width * 0.04);
                    const cardW = canvas.width * 0.92;
                    const cardX = (canvas.width - cardW) / 2;
                    const mapSize = Math.round(canvas.width * 0.22);
                    const cardH = mapSize + (padding * 2);
                    const cardY = canvas.height - cardH - padding;
                    const mapX = cardX + padding;
                    const mapY = cardY + padding;

                    ctx.fillStyle = "rgba(0, 0, 0, 0.65)";
                    ctx.fillRect(cardX, cardY, cardW, cardH);

                    let isMapHandled = false;
                    const mapImg = new Image();
                    mapImg.crossOrigin = "anonymous";
                    mapImg.src = `https://maps.googleapis.com/maps/api/staticmap?center=${lat.toFixed(6)},${lon.toFixed(6)}&zoom=16&size=300x300&scale=2&maptype=roadmap&markers=color:red|${lat.toFixed(6)},${lon.toFixed(6)}&key=${GOOGLE_MAPS_API_KEY}`;

                    const mapTimeout = setTimeout(() => {
                        if (!isMapHandled) { mapImg.onerror(); }
                    }, 5000);

                    mapImg.onload = () => {
                        if (isMapHandled) return;
                        isMapHandled = true;
                        clearTimeout(mapTimeout);
                        try { ctx.drawImage(mapImg, mapX, mapY, mapSize, mapSize); } catch (e) { console.warn("Map error", e); }
                        finishCapture(cardX, cardW, cardY, mapX, mapSize, mapY);
                    };

                    mapImg.onerror = () => {
                        if (isMapHandled) return;
                        isMapHandled = true;
                        clearTimeout(mapTimeout);

                        // Fallback drawing
                        ctx.fillStyle = "#1a1a1a";
                        ctx.fillRect(mapX, mapY, mapSize, mapSize);
                        ctx.strokeStyle = "rgba(0, 230, 118, 0.2)";
                        ctx.lineWidth = 1;
                        ctx.strokeRect(mapX, mapY, mapSize, mapSize);

                        ctx.fillStyle = "#ff5252";
                        ctx.beginPath();
                        ctx.arc(mapX + mapSize / 2, mapY + mapSize / 2, 6, 0, 2 * Math.PI);
                        ctx.fill();

                        ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
                        ctx.font = "bold 10px sans-serif";
                        ctx.textAlign = "center";
                        ctx.fillText("OFFLINE", mapX + mapSize / 2, mapY + mapSize - 10);

                        finishCapture(cardX, cardW, cardY, mapX, mapSize, mapY);
                    };

                } else {
                    // Watermark OFF
                    finishCapture(0, 0, 0, 0, 0, 0);
                }
            } catch (e) {
                console.error("Capture failed", e);
            }
        };
    }

    function finishCapture(cardX, cardW, cardY, mapX, mapSize, mapY) {
        if (!ctx) return;
        renderProWatermark(ctx, cardX, cardW, cardY, mapX, mapSize, mapY);

        const previewImg = el("photo-preview");
        if (previewImg && canvas) {
            previewImg.src = canvas.toDataURL("image/jpeg", 0.85);
            previewImg.style.display = "block";
        }

        if (saveModal) saveModal.classList.add("active");
        if (actionBar) actionBar.classList.remove("show");
    }

    // THE WATERMARK RENDER FUNCTION
    function renderProWatermark(ctxLocal, cardX, cardW, cardY, mapX, mapSize, mapY) {
        if (!canvas) return;
        const baseFS = Math.max(10, Math.round(canvas.width * 0.032));
        const padding = 12 * (canvas.width / 1080);

        ctxLocal.textAlign = "right";
        ctxLocal.font = `bold ${Math.round(baseFS * 0.6)}px sans-serif`;
        ctxLocal.fillStyle = "rgba(255, 255, 255, 0.8)";
        ctxLocal.fillText("GPS Map Camera Pro", cardX + cardW - padding, cardY + (baseFS * 0.8));

        ctxLocal.textAlign = "left";
        const textX = mapX + mapSize + (15 * (canvas.width / 1080));
        let currentY = mapY + (baseFS * 0.8);

        ctxLocal.fillStyle = "#ffffff";
        ctxLocal.font = `bold ${Math.round(baseFS * 1.0)}px sans-serif`;

        const addrParts = (address || "").split(',');
        const city = addrParts[0] || "Unknown";
        const stateCountry = addrParts.length >= 2 ? addrParts.slice(-2).join(', ').trim() : "GPS Location";
        const availableWidth = (cardX + cardW) - textX - padding;

        ctxLocal.fillText(`${city} | ${stateCountry}`, textX, currentY, availableWidth);

        ctxLocal.font = `${Math.round(baseFS * 0.7)}px sans-serif`;
        currentY += baseFS * 1.1;
        ctxLocal.fillText((address || "Searching..."), textX, currentY, availableWidth);

        currentY += baseFS * 1.0;
        ctxLocal.fillText(`Lat ${lat.toFixed(6)}Â° Long ${lon.toFixed(6)}Â°`, textX, currentY);

        currentY += baseFS * 1.0;
        const now = new Date();
        const day = now.toLocaleDateString('en-IN', { weekday: 'long' });
        const dateStr = now.toLocaleDateString('en-GB');
        const timeStr = now.toLocaleTimeString('en-IN', { hour: '2-digit', minute: '2-digit', hour12: true });
        ctxLocal.fillText(`${day}, ${dateStr} | ${timeStr}`, textX, currentY);
    }

    /* =================================================================
       STORAGE: DCIM SAVING & SHARING
       ================================================================= */
    const btnSave = el("btn-save");
    if (btnSave) {
        btnSave.onclick = async () => {
            const saveBtn = btnSave;
            const originalText = saveBtn.innerText;
            saveBtn.innerText = "Saving...";
            saveBtn.disabled = true;

            try {
                if (!canvas) throw new Error("No canvas to save from");

                const dataUrl = canvas.toDataURL("image/jpeg", 0.95);
                const base64Data = dataUrl.replace(/^data:image\/jpeg;base64,/, "");
                const fileName = `GPS_PRO_${Date.now()}.jpg`;
                const ALBUM_NAME = "GPS_Map_Camera";

                if (window.Capacitor) {
                    const { Filesystem, Media } = Capacitor.Plugins;

                    // Ensure media permission via helper
                    try {
                        const okMedia = await ensureMediaPermission();
                        if (!okMedia) throw new Error("Media permission denied");
                    } catch (e) {
                        throw e;
                    }

                    // 2. Save to CACHE
                    const temp = await Filesystem.writeFile({
                        path: fileName,
                        data: base64Data,
                        directory: "CACHE"
                    });

                    const fileUri = temp.uri && temp.uri.startsWith("file://") ? temp.uri : `file://${temp.uri}`;

                    // 3. Create album
                    let albumId;
                    try {
                        const album = await Media.createAlbum({ name: ALBUM_NAME });
                        albumId = album && album.identifier;
                    } catch (e) {
                        try {
                            const albums = await Media.getAlbums();
                            const existing = albums && albums.albums ? albums.albums.find(a => a.name === ALBUM_NAME) : null;
                            albumId = existing && existing.identifier;
                        } catch (ee) {
                            console.warn("Album creation/fetch error", ee);
                        }
                    }

                    // FINAL SAVE
                    await Media.savePhoto({
                        path: fileUri,
                        albumIdentifier: albumId
                    });
                    LAST_SAVED_PHOTO_URI = fileUri;

                    // INTERSTITIAL AD
                    if (window.Capacitor?.Plugins?.AdMob) {
                        try { await showBlockingInterstitialAd(); } catch (e) { console.warn("Interstitial not ready"); }
                    }

                    // Success UI
                    const saveOverlay = el("save-modal-overlay");
                    if (saveOverlay) saveOverlay.classList.remove("active");
                    setTimeout(() => {
                        const successModal = el("success-modal");
                        if (successModal) successModal.classList.add("active");
                    }, 500);
                } else {
                    // Browser fallback: download image
                    const a = document.createElement('a');
                    a.href = dataUrl;
                    a.download = fileName;
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                    alert("Saved to browser download folder.");
                }
            } catch (err) {
                alert("Save failed: " + (err && err.message ? err.message : err));
                console.error(err);
            } finally {
                saveBtn.innerText = originalText;
                saveBtn.disabled = false;
            }
        };
    }

    /* =================================================================
       UI UTILS & APP LIFECYCLE
       ================================================================= */
    const btnCloseBar = el("btn-close-bar");
    if (btnCloseBar) {
        btnCloseBar.onclick = () => {
            const ab = el("action-bar");
            if (ab) ab.classList.remove("show");
        };
    }

    async function showManualAlert(Dialog) {
        if (Dialog) {
            try {
                await Dialog.alert({
                    title: 'Check Folder',
                    message: 'Gallery open nahi ho saki. Photo yahan hai: \nDCIM/GPS_Map_Camera',
                    buttonTitle: 'Close'
                });
            } catch (e) {
                alert("Check folder: DCIM/GPS_Map_Camera");
            }
        } else { alert("Check folder: DCIM/GPS_Map_Camera"); }
    }

    const chkHd = el("chk-hd");
    if (chkHd) chkHd.onchange = () => { startCamera(); };

    const openSettingsBtn = el("open-settings");
    if (openSettingsBtn) openSettingsBtn.onclick = () => {
        const sp = el("settings-panel");
        if (sp) sp.classList.add("active");
    };

    const closeSettingsBtn = el("close-settings");
    if (closeSettingsBtn) closeSettingsBtn.onclick = () => {
        const sp = el("settings-panel");
        if (sp) sp.classList.remove("active");
    };

    if (accSlider && accLabel) accSlider.oninput = () => { accLabel.innerText = accSlider.value + "m"; };
    if (distSlider && distLabel) distSlider.oninput = () => { distLabel.innerText = distSlider.value + "m"; };

    document.addEventListener("keydown", (e) => {
        if (e.keyCode === 24 || e.keyCode === 25 || e.code === "VolumeUp" || e.code === "VolumeDown") {
            e.preventDefault();
            const capBtn = el("capture-btn");
            if (capBtn) capBtn.click();
        }
    });

    // CORRECTED VISIBILITY HANDLER (Prevents Overlap)
    document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
            // App background mein gayi - Camera/GPS band karo
            if (stream) {
                try { stream.getTracks().forEach(t => t.stop()); } catch(e){/*ignore*/ }
                stream = null;
            }
            if (watchId) {
                try { navigator.geolocation.clearWatch(watchId); } catch (e) { /* ignore */ }
                watchId = null;
            }
        } else {
            // App wapas aayi - Resume karo
            if (localStorage.getItem("isReady") === "true" && isSystemInitialized) {
                console.log("Resuming Hardware...");
                safeResumeHardware();
            }
        }
    });

    setInterval(() => {
        const t = el("txt-time");
        if (t) t.innerText = new Date().toLocaleString('hi-IN');
    }, 1000);

    // APP START CHECK (First Time vs Second Time)
    window.addEventListener("load", () => {
        let pct = 0;
        const pctEl = el('progress-percent');
        if (pctEl) {
            const interval = setInterval(() => {
                pct += 10;
                if (pct > 100) pct = 100;
                pctEl.innerText = pct + "%";
                if (pct === 100) clearInterval(interval);
            }, 150);
        }

        // System Checks Animation
        const items = ['item-gps', 'item-map', 'item-cam', 'item-secure'];
        items.forEach((id, i) => {
            setTimeout(() => {
                const element = el(id);
                if (element) {
                    element.classList.add('active');
                    const icon = element.querySelector('.status-icon');
                    if (icon) icon.innerText = "check_circle";
                    element.style.color = '#00e676';
                }
            }, 300 + (i * 300));
        });

        setTimeout(() => {
            const splash = el("intro-splash");
            const screen = el("perm-screen");

            if (localStorage.getItem("isReady") === "true") {
                if (splash) splash.style.display = "none";
                if (screen) screen.style.display = "none";
                // Seedha Camera Chalu Karo
                initializeSystem().catch(e => console.error("init on load failed", e));
            } else {
                if (splash) splash.style.display = "none";
                if (screen) screen.style.display = "flex";
            }
        }, 2500);
    });

    /* =================================================================
       ANDROID BACK BUTTON LOGIC
       ================================================================= */
    function isHomeScreenAuto() {
        // Check active modal/panels
        if (document.querySelector(".modal-overlay.active")) return false;

        const settingsModal = el("settings-panel");
        if (settingsModal && settingsModal.classList.contains("active")) return false;

        const saveOverlay = el("save-modal-overlay");
        if (saveOverlay && saveOverlay.classList.contains("active")) return false;

        const photoPreview = el("photo-preview");
        if (photoPreview && photoPreview.style.display === "block") return false;

        if (!video || video.readyState < 2) return false;

        const style = window.getComputedStyle(video);
        if (style.display === "none" || style.visibility === "hidden") return false;

        return true;
    }

    document.addEventListener("backbutton", () => {
        if (!isHomeScreenAuto()) {
            // Close Active Modals
            const modal = document.querySelector(".modal-overlay.active");
            if (modal) { modal.classList.remove("active"); return; }

            const saveOverlay = el("save-modal-overlay");
            if (saveOverlay && saveOverlay.classList.contains("active")) {
                saveOverlay.classList.remove("active");
                return;
            }

            const settings = el("settings-panel");
            if (settings && settings.classList.contains("active")) {
                settings.classList.remove("active");
                return;
            }

            return;
        }

        // Home Screen Exit
        if (window.Capacitor?.Plugins?.Dialog) {
            try {
                Capacitor.Plugins.Dialog.confirm({
                    title: "Exit App",
                    message: "Do you want to close the app?",
                    okButtonTitle: "Yes",
                    cancelButtonTitle: "No"
                }).then(result => {
                    if (result.value) {
                        try { navigator.app.exitApp(); } catch (e) { /* ignore */ }
                    }
                });
            } catch (e) {
                if (confirm("Do you want to close the app?")) {
                    try { navigator.app.exitApp(); } catch (x) { /* ignore */ }
                }
            }
        } else {
            if (confirm("Do you want to close the app?")) {
                try { navigator.app.exitApp(); } catch (e) { /* ignore */ }
            }
        }
    });

    // DISCARD BUTTON LOGIC
    const btnDiscard = el("btn-discard");
    if (btnDiscard) {
        btnDiscard.onclick = () => {
            const saveOverlay = el("save-modal-overlay");
            if (saveOverlay) saveOverlay.classList.remove("active");

            const previewImg = el("photo-preview");
            if (previewImg) {
                previewImg.src = "";
                previewImg.style.display = "none";
            }

            if (canvas && ctx) {
                try { ctx.clearRect(0, 0, canvas.width, canvas.height); } catch (e) { /* ignore */ }
            }

            const actionBarEl = el("action-bar");
            if (actionBarEl) actionBarEl.classList.remove("show");
        };
    }

    // Hook start button(s)
    const btnStart = el("btn-start");
    if (btnStart) btnStart.onclick = handleStart;

    const btnRetryPermissions = el("btn-retry-permissions");
    if (btnRetryPermissions) btnRetryPermissions.onclick = () => {
        // Show permission content again and let user try
        const denied = el("denied-content"), permC = el("perm-content");
        if (denied && permC) {
            denied.style.display = "none";
            permC.style.display = "block";
        }
    };

    // Success modal share/close button hooks
    const shareSuccessBtn = el("share-success-btn");
    if (shareSuccessBtn) shareSuccessBtn.onclick = shareOnWhatsApp;
    const closeSuccessBtnEl = el("close-success-btn");
    if (closeSuccessBtnEl) closeSuccessBtnEl.onclick = () => {
        const successModalEl = el("success-modal");
        if (successModalEl) successModalEl.classList.remove("active");
    };

    // Share button in action bar
    const btnShareWhatsapp = el("btn-share-whatsapp");
    if (btnShareWhatsapp) btnShareWhatsapp.onclick = shareOnWhatsApp;

    // Make sure share button inside success modal closes when used
    if (el("success-modal")) {
        // no-op: handlers above already attached
    }

</script>
</body>
</html>
